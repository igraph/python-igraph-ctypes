{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"python-igraph-ctypes","text":"<p>This repository contains an experimental Python API to the igraph C library, with the following goals:</p> <ul> <li> <p>It should contain as little hand-written C code as possible.</p> </li> <li> <p>It should rely on code generation to create most of the glue code between   Python and igraph's core C API to make it easier to adapt to changes in the   underlying C library without having to re-write too much of the Python code.</p> </li> <li> <p>It should provide full type annotations.</p> </li> </ul>"},{"location":"#status","title":"Status","text":"<p>This repo is highly experimental and currently it is only in a proof-of-concept stage. The vast majority of igraph's API is not exposed, and things may break randomly, or they may not even work.</p>"},{"location":"#usage","title":"Usage","text":"<ol> <li> <p>Clone the repo.</p> </li> <li> <p>Install <code>uv</code> if you don't have it yet.</p> </li> <li> <p>Run <code>uv sync</code> to prepare a virtualenv with all the required    dependencies.</p> </li> <li> <p>Run <code>uv run pytest</code> to run the unit tests, or <code>uv run python</code> to run    a Python interpreter where you can <code>import igraph_ctypes</code></p> </li> </ol>"},{"location":"#benchmarking","title":"Benchmarking","text":"<p>Benchmarks will be placed in <code>benchmarks</code> and they will compare the \"old\", official Python interface of igraph with this new implementation. To run the benchmarks, type <code>uv run richbench benchmarks</code>.</p>"},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Apparently you'll need to ensure that the igraph shared library is built   without sanitizers, otherwise the <code>dlopen()</code> call fails, at least on macOS.</li> </ul>"},{"location":"notes/","title":"Open questions","text":"<p>Open questions to be discussed regarding the design of the new igraph Python interface:</p> <ul> <li> <p>Shall we allow string representations of enums to be resolved to their   corresponding enum values? This would make it possible to write something   like <code>\"directed\"</code> instead of <code>Adjacency.DIRECTED</code>.</p> </li> <li> <p>Shall we allow the user to refer to vertices by strings and resolve strings   automatically to vertex names, or do we want to force the user to indicate   explicitly when he wants to do a by-name lookup?</p> </li> <li> <p>Shall we allow the user to refer to individual edges by a <code>(source, target)</code>   tuple if it is unambiguous?</p> </li> <li> <p>Shall we allow the user to specify edge weight vectors simply by writing the   name of the edge attribute storing the weights?</p> </li> <li> <p>Shall we treat the <code>weight</code> edge attribute implicitly as edge weights?</p> </li> <li> <p>Shall we allow dicts mapping vertex names to floats to be treated as a   <code>VERTEX_QTY</code> abstract type?</p> </li> </ul>"},{"location":"api/constructors/","title":"Graph constructors","text":""},{"location":"api/constructors/#igraph_ctypesconstructors-module","title":"<code>igraph_ctypes.constructors</code> module","text":""},{"location":"api/constructors/#igraph_ctypes.constructors.create_empty_graph","title":"<code>create_empty_graph(n=0, directed=False)</code>","text":"<p>Creates an empty graph with the given number of vertices.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of vertices</p> <code>0</code> <code>directed</code> <code>bool</code> <p>whether the graph is directed</p> <code>False</code> <p>Returns:</p> Type Description <code>Graph</code> <p>the newly created graph</p>"},{"location":"api/constructors/#igraph_ctypes.constructors.create_famous_graph","title":"<code>create_famous_graph(name)</code>","text":"<p>Creates one of the \"famous\" graphs embedded into igraph by name.</p> <p>See the documentation of the <code>igraph_famous()</code> function in igraph's C core for a list of names accepted by this function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the graph to construct</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>the constructed graph</p>"},{"location":"api/constructors/#igraph_ctypes.constructors.create_full_graph","title":"<code>create_full_graph(n, directed=False, loops=False)</code>","text":"<p>Creates a full graph with the given number of vertices.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of vertices</p> required <code>directed</code> <code>bool</code> <p>whether the graph is directed</p> <code>False</code> <code>loops</code> <code>bool</code> <p>whether each vertex should also have a loop edge</p> <code>False</code> <p>Returns:</p> Type Description <code>Graph</code> <p>the newly created graph</p>"},{"location":"api/constructors/#igraph_ctypes.constructors.create_geometric_random_graph","title":"<code>create_geometric_random_graph(n, radius, torus=False)</code>","text":"<p>Creates a geometric random graph.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of vertices in the graph</p> required <code>radius</code> <code>float</code> <p>connection distance; two vertices will be connected if they are closer to each other than this threshold</p> required"},{"location":"api/constructors/#igraph_ctypes.constructors.create_graph_from_edge_list","title":"<code>create_graph_from_edge_list(edges, n=0, directed=True)</code>","text":"<p>Creates a graph from the given edge list.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[int]</code> <p>the list of edges in the graph</p> required <code>n</code> <code>int</code> <p>the number of vertices in the graph if it cannot be inferred from the maximum edge ID in the edge list</p> <code>0</code> <p>Returns:</p> Type Description <code>Graph</code> <p>the newly created graph</p>"},{"location":"api/constructors/#igraph_ctypes.constructors.create_square_lattice","title":"<code>create_square_lattice(dimvector, nei=1, directed=False, mutual=False, periodic=False)</code>","text":"<p>Creates a square lattice graph.</p> <p>Parameters:</p> Name Type Description Default <code>dimvector</code> <code>Iterable[int]</code> <p>number of vertices along each dimension of the lattice</p> required <code>directed</code> <code>bool</code> <p>whether the generated lattice should be directed</p> <code>False</code> <code>mutual</code> <code>bool</code> <p>whether the vertices should be connected in both directions if the lattice is directed</p> <code>False</code> <code>periodic</code> <code>Union[bool, Iterable[bool]]</code> <p>whether the lattice should be periodic along each dimension. <code>True</code> or <code>False</code> means a periodic or an aperiodic lattice along all dimensions. You may supply an iterable having the same length as the number of dimensions to specify periodicity along each dimension separately.</p> <code>False</code>"},{"location":"api/graph/","title":"The Graph class","text":"<p>A graph object.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.attrs","title":"<code>attrs</code>  <code>property</code>","text":"<p>Provides access to the user-defined attributes of the graph.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.eattrs","title":"<code>eattrs</code>  <code>property</code>","text":"<p>Provides access to the user-defined attributes of the edges of the graph.</p> <p>This property is experimental; it might be removed any time.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.vattrs","title":"<code>vattrs</code>  <code>property</code>","text":"<p>Provides access to the user-defined attributes of the vertices of the graph.</p> <p>This property is experimental; it might be removed any time.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.__init__","title":"<code>__init__(*args, _wrap=None, **kwds)</code>","text":"<p>Constructor.</p> <p>Creates an empty graph. All positional and keyword arguments are forwarded to <code>create_empty_graph()</code>, except <code>_wrap</code>, which may be used to let the graph take the ownership of a low-level ctypes wrapper object for an igraph graph. Typically you will not need to use <code>_wrap</code>.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.add_vertices","title":"<code>add_vertices(n)</code>","text":"<p>Adds new vertices to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the number of vertices to add</p> required <p>Returns:</p> Type Description <code>C</code> <p>the graph itself</p>"},{"location":"api/graph/#igraph_ctypes.Graph.convert_to_directed","title":"<code>convert_to_directed(mode='mutual')</code>","text":"<p>Converts the graph in-place to a directed graph if it is undirected.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['arbitrary', 'mutual', 'random', 'acyclic']</code> <p>specifies how to convert the graph to directed. <code>\"arbitrary\"</code> picks a direction for each edge in an arbitrary but deterministic manner. <code>\"mutual\"</code> creates a mutual directed edge pair for each undirected edge. <code>\"random\"</code> picks a direction for each edge randomly. <code>\"acyclic\"</code> picks a direction for each edge in a way that ensures that the directed graph is acyclic.</p> <code>'mutual'</code> <p>Returns:</p> Type Description <code>C</code> <p>the graph itself</p>"},{"location":"api/graph/#igraph_ctypes.Graph.convert_to_undirected","title":"<code>convert_to_undirected(mode='collapse', edge_attr_comb=None)</code>","text":"<p>Converts the graph in-place to an undirected graph if it is directed.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['collapse', 'each', 'mutual']</code> <p>specifies how to convert the graph to undirected. `\"each<code>creates a single undirected edge for each directed edge.</code>mutual<code>creates a single undirected edge for every directed mutual edge pair and removes directed edges that do not have a pair in the opposite direction.</code>collapse`` collapses multiple directed edges (irrespectively of their direction) between the same vertex pair into a single undirected edge.</p> <code>'collapse'</code> <code>edge_attr_comb</code> <code>Optional[AttributeCombinationSpecification]</code> <p>specifies what to do with the attributes of edges when multiple edges are collapsed into a single edge during the conversion process.</p> <code>None</code> <p>Returns:</p> Type Description <code>C</code> <p>the graph itself</p>"},{"location":"api/graph/#igraph_ctypes.Graph.copy","title":"<code>copy()</code>","text":"<p>Creates a copy of the graph.</p> <p>The copy will have a vertex and an edge set that is independent from the original graph. Graph, vertex and edge attributes are copied in a shallow manner, i.e. the attribute mapping itself is copied but the values will point to the same objects.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.ecount","title":"<code>ecount()</code>","text":"<p>Returns the number of edges in the graph.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.edge","title":"<code>edge(eid)</code>","text":"<p>Returns the endpoints of the edge with the given index from the graph.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.get_edge_id","title":"<code>get_edge_id(from_, to, *, directed=True, error=True)</code>","text":"<p>Returns the ID of an arbitrary edge between the given source and target vertices.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.is_directed","title":"<code>is_directed()</code>","text":"<p>Returns whether the graph is directed.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.neighbors","title":"<code>neighbors(vid, mode=NeighborMode.ALL)</code>","text":"<p>Returns the list of neighbors of a vertex.</p>"},{"location":"api/graph/#igraph_ctypes.Graph.vcount","title":"<code>vcount()</code>","text":"<p>Returns the number of vertices in the graph.</p>"},{"location":"api/io/","title":"Reading and writing graphs","text":""},{"location":"api/io/#igraph_ctypesio-module","title":"<code>igraph_ctypes.io</code> module","text":""},{"location":"api/io/#igraph_ctypes.io.write_graph_edgelist","title":"<code>write_graph_edgelist(graph, outstream)</code>","text":"<p>Writes the graph in plain edge list format to an output stream.</p> <p>The plain edge list format records the structure of the graph only and the vertices of the graph will be referred to as numeric vertex IDs instead of vertex names.</p> <p>See <code>write_graph_ncol()</code> if you have vertex names and you want to use them in the output file instead of IDs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the graph to write</p> required <code>outstream</code> <code>FileLike</code> <p>the output file or stream to write the graph to. May be a filename, a path-like object or a file-like object if it is backed by a low-level file handle</p> required"},{"location":"api/io/#igraph_ctypes.io.write_graph_graphml","title":"<code>write_graph_graphml(graph, outstream, prefixattr=True)</code>","text":"<p>Writes the graph in GraphML format to an output stream.</p> <p>The GraphML format preserves numeric, string and boolean attributes.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the graph to write</p> required <code>outstream</code> <code>FileLike</code> <p>the output file or stream to write the graph to. May be a filename, a path-like object or a file-like object if it is backed by a low-level file handle</p> required <code>prefixattr</code> <code>bool</code> <p>whether to put a prefix in front of the attribute names to ensure uniqueness if the graph has vertex and edge (or graph) attributes with the same name</p> <code>True</code>"},{"location":"api/io/#igraph_ctypes.io.write_graph_lgl","title":"<code>write_graph_lgl(graph, outstream, names='name', weights='weight', isolates=True)</code>","text":"<p>Writes the graph in the LGL (Large Graph Layout) format to an output stream.</p> <p>The LGL format can store the structure of a graph with named vertices and weighted edges.</p> <p>Note that the file format does not store whether the graph is directed or not; this information has to be supplied when the graph is read back.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the graph to write</p> required <code>outstream</code> <code>FileLike</code> <p>the output file or stream to write the graph to. May be a filename, a path-like object or a file-like object if it is backed by a low-level file handle</p> required <code>names</code> <code>str</code> <p>name of the string vertex attribute that stores the names of the vertices to be written into the output file. A warning will be thrown if the attribute does not exist or is not a string attribute, and the file will contain numeric vertex IDs instead if this is the case.</p> <code>'name'</code> <code>weights</code> <code>str</code> <p>name of the edge attribute that stores the weights of the edges to be written into the output file. A warning will be thrown if the attribute does not exist or is not a numeric attribute, and all weights will be assumed to be equal to 1 if this is the case.</p> <code>'weight'</code> <code>isolates</code> <code>bool</code> <p>whether to save isolated vertices to the output</p> <code>True</code>"},{"location":"api/io/#igraph_ctypes.io.write_graph_ncol","title":"<code>write_graph_ncol(graph, outstream, names='name', weights='weight')</code>","text":"<p>Writes the graph in the NCOL format to an output stream.</p> <p>The NCOL format is essentially a two- or three-column named edge list format. Each line in the output corresponds to an edge. The first two columns contain the names of the source and target vertices of an edge. THe third column (if exists) contains the weight of each edge.</p> <p>Note that the file format does not store whether the graph is directed or not; this information has to be supplied when the graph is read back.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the graph to write</p> required <code>outstream</code> <code>FileLike</code> <p>the output file or stream to write the graph to. May be a filename, a path-like object or a file-like object if it is backed by a low-level file handle</p> required <code>names</code> <code>str</code> <p>name of the string vertex attribute that stores the names of the vertices to be written into the output file. A warning will be thrown if the attribute does not exist or is not a string attribute, and the file will contain numeric vertex IDs instead if this is the case.</p> <code>'name'</code> <code>weights</code> <code>str</code> <p>name of the edge attribute that stores the weights of the edges to be written into the output file. A warning will be thrown if the attribute does not exist or is not a numeric attribute, and all weights will be assumed to be equal to 1 if this is the case.</p> <code>'weight'</code>"},{"location":"api/paths/","title":"Shortest paths and components","text":""},{"location":"api/paths/#igraph_ctypespaths-module","title":"<code>igraph_ctypes.paths</code> module","text":"<p>Functions related to shortest or widest paths in a graph.</p>"},{"location":"api/paths/#igraph_ctypes.paths.components","title":"<code>components(graph, mode=Connectedness.WEAK)</code>","text":"<p>Finds the weakly or strongly connected components of a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the graph</p> required <code>mode</code> <code>Connectedness</code> <p>whether the function should return weakly or strongly connected components</p> <code>WEAK</code>"},{"location":"api/paths/#igraph_ctypes.paths.shortest_path","title":"<code>shortest_path(graph, source, target, mode=NeighborMode.OUT, weights=None, method='dijkstra')</code>","text":"<p>Finds a single shortest path between two vertices in a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the graph</p> required <code>source</code> <code>VertexLike</code> <p>the source vertex</p> required <code>target</code> <code>VertexLike</code> <p>the target vertex</p> required <code>mode</code> <code>NeighborMode</code> <p>TODO</p> <code>OUT</code> <code>weights</code> <code>Optional[Iterable[float]]</code> <p>list of weights for each edge in the graph, or <code>None</code> to treat the edges as unweighted</p> <code>None</code> <code>method</code> <code>str</code> <p>the method to use for finding shortest paths when the graph is weighted. May be one of <code>\"dijkstra\"</code> (Dijkstra's algorithm) or <code>\"bellman-ford\"</code> (Bellman-Ford algorithm).</p> <code>'dijkstra'</code> <p>Returns:</p> Type Description <code>IntArray</code> <p>the IDs of the vertices along the shortest path</p>"},{"location":"api/types/","title":"Basic data types","text":""},{"location":"api/types/#igraph_ctypestypes-module","title":"<code>igraph_ctypes.types</code> module","text":""},{"location":"api/types/#igraph_ctypes.types.AttributeCombinationSpecification","title":"<code>AttributeCombinationSpecification = Mapping[str | None, AttributeCombinationSpecificationEntry] | AttributeCombinationSpecificationEntry</code>  <code>module-attribute</code>","text":"<p>Type alias for mappings that specify how to merge vertex or edge attributes during an operation that contracts multiple vertices or edge into a single one.</p> <p><code>None</code> specifies the default behaviour.</p>"},{"location":"api/types/#igraph_ctypes.types.AttributeCombinationSpecificationEntry","title":"<code>AttributeCombinationSpecificationEntry = Literal['default', 'ignore', 'sum', 'prod', 'min', 'max', 'random', 'first', 'last', 'mean', 'median', 'concat'] | Callable[[Sequence[Any]], Any]</code>  <code>module-attribute</code>","text":"<p>Type alias for values that can be accepted in an AttributeCombinationSpecification_ mapping.</p>"},{"location":"api/types/#igraph_ctypes.types.BoolArray","title":"<code>BoolArray = npt.NDArray[np_type_of_igraph_bool_t]</code>  <code>module-attribute</code>","text":"<p>Type alias for NumPy arrays containing igraph booleans</p>"},{"location":"api/types/#igraph_ctypes.types.EdgeLike","title":"<code>EdgeLike = int</code>  <code>module-attribute</code>","text":"<p>Type alias for Python types that can be converted to an igraph edge ID</p>"},{"location":"api/types/#igraph_ctypes.types.EdgeSelector","title":"<code>EdgeSelector = Iterable[EdgeLike] | Literal['all'] | EdgeLike | None</code>  <code>module-attribute</code>","text":"<p>Type alias for Python types that can be converted to an igraph edge selector.</p>"},{"location":"api/types/#igraph_ctypes.types.FileLike","title":"<code>FileLike = int | bytes | str | PathLike[bytes] | PathLike[str] | IOBase</code>  <code>module-attribute</code>","text":"<p>Type alias for Python types that can be used in places where the C core expects a FILE* pointer.</p>"},{"location":"api/types/#igraph_ctypes.types.IntArray","title":"<code>IntArray = npt.NDArray[np_type_of_igraph_integer_t]</code>  <code>module-attribute</code>","text":"<p>Type alias for NumPy arrays containing igraph integers</p>"},{"location":"api/types/#igraph_ctypes.types.RealArray","title":"<code>RealArray = npt.NDArray[np_type_of_igraph_real_t]</code>  <code>module-attribute</code>","text":"<p>Type alias for NumPy arrays containing igraph reals</p>"},{"location":"api/types/#igraph_ctypes.types.VertexLike","title":"<code>VertexLike = int</code>  <code>module-attribute</code>","text":"<p>Type alias for Python types that can be converted to an igraph vertex ID</p>"},{"location":"api/types/#igraph_ctypes.types.VertexPair","title":"<code>VertexPair = tuple[VertexLike, VertexLike]</code>  <code>module-attribute</code>","text":"<p>A pair of objects that can both be converted into igraph vertex IDs</p>"},{"location":"api/types/#igraph_ctypes.types.VertexSelector","title":"<code>VertexSelector = Iterable[VertexLike] | Literal['all'] | VertexLike | None</code>  <code>module-attribute</code>","text":"<p>Type alias for Python types that can be converted to an igraph vertex selector.</p>"}]}