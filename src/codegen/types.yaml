ERROR:
  PY_TYPE: int
  CTYPES_RETURN_TYPE: handle_igraph_error_t

BOOLEAN:
  PY_TYPE: bool
  INCONV:
    IN: "%C% = any_to_igraph_bool_t(%I%)"
    OUT: "%C% = igraph_bool_t()"

INTEGER:
  PY_TYPE: int
  INCONV:
    OUT: "%C% = igraph_integer_t()"

REAL:
  PY_TYPE: float
  INCONV:
    OUT: "%C% = igraph_real_t()"

INT:
  PY_TYPE: int
  INCONV:
    OUT: "%C% = c_int()"

DOUBLE:
  PY_TYPE: float
  INCONV:
    OUT: "%C% = c_double()"

CSTRING:
  PY_TYPE: str
  INCONV:
    IN: '%C% = %I%.encode("utf-8")'
    OUT: "%C% = c_char_p()"
  OUTCONV: "%I% = bytes_to_str(%C%)"

VECTOR:
  PY_TYPE: Iterable[float]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_real_t]
  INCONV:
    IN: "%C% = iterable_to_igraph_vector_t_view(%I%)"
    INOUT: "%C% = iterable_to_igraph_vector_t(%I%)"
    OUT: "%C% = _Vector.create(0)"
  OUTCONV: "%I% = igraph_vector_t_to_numpy_array(%C%)"

VECTOR_INT:
  PY_TYPE: Iterable[int]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = iterable_to_igraph_vector_int_t_view(%I%)"
    INOUT: "%C% = iterable_to_igraph_vector_int_t(%I%)"
    OUT: "%C% = _VectorInt.create(0)"
  OUTCONV: "%I% = igraph_vector_int_t_to_numpy_array(%C%)"

VECTOR_BOOL:
  # we can convert anything into a bool
  PY_TYPE: Iterable[Any]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_bool_t]
  INCONV:
    IN: "%C% = iterable_to_igraph_vector_bool_t_view(%I%)"
    INOUT: "%C% = iterable_to_igraph_vector_bool_t(%I%)"
    OUT: "%C% = _VectorBool.create(0)"
  OUTCONV: "%I% = igraph_vector_bool_t_to_numpy_array(%C%)"

INDEX_VECTOR:
  PY_TYPE: Iterable[int]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = iterable_to_igraph_vector_int_t_view(%I%)"
    INOUT: "%C% = iterable_to_igraph_vector_int_t(%I%)"
    OUT: "%C% = _VectorInt.create(0)"
  OUTCONV: "%I% = igraph_vector_int_t_to_numpy_array(%C%)"

MATRIX:
  PY_TYPE: MatrixLike
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_real_t]
  INCONV:
    IN: "%C% = sequence_to_igraph_matrix_t_view(%I%)"
    INOUT: "%C% = sequence_to_igraph_matrix_t(%I%)"
    OUT: "%C% = _Matrix.create(0)"
  OUTCONV: "%I% = igraph_matrix_t_to_numpy_array(%C%)"

MATRIX_INT:
  PY_TYPE: MatrixIntLike
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = sequence_to_igraph_matrix_int_t_view(%I%)"
    INOUT: "%C% = sequence_to_igraph_matrix_int_t(%I%)"
    OUT: "%C% = _MatrixInt.create(0)"
  OUTCONV: "%I% = igraph_matrix_int_t_to_numpy_array(%C%)"

GRAPH:
  PY_TYPE: _Graph
  INCONV:
    OUT: "%C% = _Graph()"
  OUTCONV:
    OUT: |-
      %I% = %C%.mark_initialized()
    INOUT: ~

ATTRIBUTES:
  PY_TYPE: ~

VERTEX:
  PY_TYPE: VertexLike
  PY_RETURN_TYPE: int
  INCONV:
    IN: "%C% = vertexlike_to_igraph_integer_t(%I%)"
    OUT: "%C% = igraph_integer_t(0)"

VERTEX_COLOR:
  PY_TYPE: Iterable[int]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = vertex_colors_to_igraph_vector_int_t_view(%I%, %I1%)"
    INOUT: "%C% = vertex_colors_to_igraph_vector_int_t(%I%, %I1%)"
    OUT: "%C% = _VectorInt.create(0)"
  OUTCONV: "%I% = igraph_vector_int_t_to_numpy_array(%C%)"

VERTEX_INDICES:
  PY_TYPE: Iterable[VertexLike]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = iterable_vertex_indices_to_igraph_vector_int_t(%I%)"
    OUT: "%C% = _VectorInt.create(0)"
  OUTCONV: "%I% = igraph_vector_int_t_to_numpy_array(%C%)"

VERTEX_INDEX_PAIRS:
  PY_TYPE: Iterable[VertexPair]
  INCONV:
    IN: "%C% = vertex_pairs_to_igraph_vector_int_t(%I%)"
    OUT: "%C% = _VectorInt.create(0)"

VERTEX_SELECTOR:
  PY_TYPE: VertexSelector
  INCONV:
    IN: "%C% = vertex_selector_to_igraph_vs_t(%I%, %I1%)"
  DEFAULT:
    ALL: '"all"'
  CALL: "%C%.unwrap()"

VERTEX_QTY:
  PY_TYPE: Iterable[float]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_real_t]
  INCONV:
    IN: "%C% = vertex_qty_to_igraph_vector_t_view(%I%, %I1%)"
    INOUT: "%C% = vertex_qty_to_igraph_vector_t(%I%, %I1%)"
    OUT: "%C% = _Vector.create(0)"
  OUTCONV: "%I% = igraph_vector_t_to_numpy_array(%C%)"

EDGE:
  PY_TYPE: EdgeLike
  PY_RETURN_TYPE: int
  INCONV:
    IN: "%C% = edgelike_to_igraph_integer_t(%I%)"
    OUT: "%C% = igraph_integer_t(0)"

EDGE_COLOR:
  PY_TYPE: Iterable[int]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = edge_colors_to_igraph_vector_int_t_view(%I%, %I1%)"
    INOUT: "%C% = edge_colors_to_igraph_vector_int_t(%I%, %I1%)"
    OUT: "%C% = _VectorInt.create(0)"
  OUTCONV: "%I% = igraph_vector_int_t_to_numpy_array(%C%)"

EDGE_INDICES:
  PY_TYPE: Iterable[EdgeLike]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_integer_t]
  INCONV:
    IN: "%C% = iterable_edge_indices_to_igraph_vector_int_t(%I%)"
    OUT: "%C% = _VectorInt.create(0)"
  OUTCONV: "%I% = igraph_vector_int_t_to_numpy_array(%C%)"

EDGE_SELECTOR:
  PY_TYPE: EdgeSelector
  INCONV:
    IN: "%C% = edge_selector_to_igraph_es_t(%I%, %I1%)"
  DEFAULT:
    ALL: '"all"'
  CALL: "%C%.unwrap()"

EDGEWEIGHTS:
  PY_TYPE: Iterable[float]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_real_t]
  INCONV:
    IN: "%C% = edge_weights_to_igraph_vector_t_view(%I%, %I1%)"
    INOUT: "%C% = edge_weights_to_igraph_vector_t(%I%, %I1%)"
    OUT: "%C% = _Vector.create(0)"
  OUTCONV: "%I% = igraph_vector_t_to_numpy_array(%C%)"

EDGE_CAPACITY:
  PY_TYPE: Iterable[float]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_real_t]
  INCONV:
    IN: "%C% = edge_capacities_to_igraph_vector_t_view(%I%, %I1%)"
    INOUT: "%C% = edge_capacities_to_igraph_vector_t(%I%, %I1%)"
    OUT: "%C% = _Vector.create(0)"
  OUTCONV: "%I% = igraph_vector_t_to_numpy_array(%C%)"

BIPARTITE_TYPES:
  PY_TYPE: Iterable[Any]
  PY_RETURN_TYPE: npt.NDArray[np_type_of_igraph_bool_t]
  INCONV:
    IN: "%C% = iterable_to_igraph_vector_bool_t_view(%I%) if %I% is not None else None"
    INOUT: "%C% = iterable_to_igraph_vector_bool_t(%I%) if %I% is not None else None"
    OUT: "%C% = _VectorBool.create(0)"

ADJACENCY_MODE:
  PY_TYPE: AdjacencyMode
  INCONV:
    IN: "%C% = c_int(%I%)"

BARABASI_ALGORITHM:
  PY_TYPE: BarabasiAlgorithm
  INCONV:
    IN: "%C% = c_int(%I%)"

COMMCMP:
  PY_TYPE: CommunityComparison
  INCONV:
    IN: "%C% = c_int(%I%)"

CONNECTEDNESS:
  PY_TYPE: Connectedness
  INCONV:
    IN: "%C% = c_int(%I%)"

DEGSEQ_MODE:
  PY_TYPE: DegreeSequenceMode
  INCONV:
    IN: "%C% = c_int(%I%)"

EIGENALGO:
  PY_TYPE: EigenAlgorithm
  INCONV:
    IN: "%C% = c_int(%I%)"

FAS_ALGORITHM:
  PY_TYPE: FeedbackArcSetAlgorithm
  INCONV:
    IN: "%C% = c_int(%I%)"

FWALGORITHM:
  PY_TYPE: FloydWarshallAlgorithm
  INCONV:
    IN: "%C% = c_int(%I%)"

IMITATE_ALGORITHM:
  PY_TYPE: ImitateAlgorithm
  INCONV:
    IN: "%C% = c_int(%I%)"

LOOPS:
  PY_TYPE: Loops
  INCONV:
    IN: "%C% = c_int(%I%)"

NEIMODE:
  PY_TYPE: NeighborMode
  INCONV:
    IN: "%C% = c_int(%I%)"

OPTIMALITY:
  PY_TYPE: Optimality
  INCONV:
    IN: "%C% = c_int(%I%)"

PAGERANKALGO:
  PY_TYPE: PagerankAlgorithm
  INCONV:
    IN: "%C% = c_int(%I%)"

RANDOM_TREE_METHOD:
  PY_TYPE: RandomTreeMethod
  INCONV:
    IN: "%C% = c_int(%I%)"

RECIP:
  PY_TYPE: Reciprocity
  INCONV:
    IN: "%C% = c_int(%I%)"

REWIRING_MODE:
  PY_TYPE: Rewiring
  INCONV:
    IN: "%C% = c_int(%I%)"

ROOTCHOICE:
  PY_TYPE: RootChoice
  INCONV:
    IN: "%C% = c_int(%I%)"

RWSTUCK:
  PY_TYPE: RandomWalkStuck
  INCONV:
    IN: "%C% = c_int(%I%)"

SPINCOMMUPDATE:
  PY_TYPE: SpinglassUpdateMode
  INCONV:
    IN: "%C% = c_int(%I%)"

SPINGLASS_IMPLEMENTATION:
  PY_TYPE: SpinglassImplementation
  INCONV:
    IN: "%C% = c_int(%I%)"

STAR_MODE:
  PY_TYPE: StarMode
  INCONV:
    IN: "%C% = c_int(%I%)"

SUBGRAPH_IMPL:
  PY_TYPE: SubgraphImplementation
  INCONV:
    IN: "%C% = c_int(%I%)"

TRANSITIVITY_MODE:
  PY_TYPE: TransitivityMode
  INCONV:
    IN: "%C% = c_int(%I%)"

TREE_MODE:
  PY_TYPE: TreeMode
  INCONV:
    IN: "%C% = c_int(%I%)"

VORONOI_TIEBREAKER:
  PY_TYPE: VoronoiTiebreaker
  INCONV:
    IN: "%C% = c_int(%I%)"

WHEEL_MODE:
  PY_TYPE: WheelMode
  INCONV:
    IN: "%C% = c_int(%I%)"
