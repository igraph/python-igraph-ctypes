from __future__ import annotations

from contextlib import ExitStack
from ctypes import c_char_p, c_int
from typing import Any, Iterable, Optional, TYPE_CHECKING

from .conversion import *  # noqa
from .enums import *  # noqa
from .lib import *  # noqa
from .types import (
    AttributeCombinationSpecification,
    BoolArray,
    EdgeLike,
    EdgeSelector,
    FileLike,
    IntArray,
    MatrixLike,
    MatrixIntLike,
    RealArray,
    VertexLike,
    VertexPair,
    VertexSelector,
)
from .wrappers import (
    _Graph,
    _Matrix,
    _MatrixInt,
    _Vector,
    _VectorBool,
    _VectorInt,
    _VectorIntList,
    _create_graph_from_boxed,
)

if TYPE_CHECKING:
    from igraph_ctypes.graph import Graph

# fmt: off
# flake8: noqa: E743
# The rest of this file is generated by Stimulus


def empty(n: int = 0, directed: bool = False) -> Graph:
    """Creates an empty graph with the given number of vertices.

    Parameters:
        n: the number of vertices
        directed: whether the graph is directed

    Returns:
        the newly created graph
    """
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_empty(c_graph, c_n, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def add_edges(graph: Graph, edges: Iterable[VertexPair]) -> None:
    """Type-annotated wrapper for ``igraph_add_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_edges = vertex_pairs_to_igraph_vector_int_t(edges)
    c_attr = None

    # Call wrapped function
    igraph_add_edges(c_graph, c_edges, c_attr)


def add_vertices(graph: Graph, nv: int) -> None:
    """Type-annotated wrapper for ``igraph_add_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_nv = nv
    c_attr = None

    # Call wrapped function
    igraph_add_vertices(c_graph, c_nv, c_attr)


def copy(from_: Graph) -> Graph:
    """Type-annotated wrapper for ``igraph_copy``."""
    # Prepare input arguments
    c_to = _Graph()
    c_from = from_

    # Call wrapped function
    igraph_copy(c_to, c_from)

    # Prepare output arguments
    to = _create_graph_from_boxed(c_to)

    # Construct return value
    return to


def delete_edges(graph: Graph, edges: EdgeSelector) -> None:
    """Type-annotated wrapper for ``igraph_delete_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_edges = edge_selector_to_igraph_es_t(edges, graph)

    # Call wrapped function
    igraph_delete_edges(c_graph, c_edges.unwrap())


def delete_vertices(graph: Graph, vertices: VertexSelector) -> None:
    """Type-annotated wrapper for ``igraph_delete_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = vertex_selector_to_igraph_vs_t(vertices, graph)

    # Call wrapped function
    igraph_delete_vertices(c_graph, c_vertices.unwrap())


def delete_vertices_map(graph: Graph, vertices: VertexSelector) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_delete_vertices_map``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = vertex_selector_to_igraph_vs_t(vertices, graph)
    c_idx = _VectorInt.create(0)
    c_invidx = _VectorInt.create(0)

    # Call wrapped function
    igraph_delete_vertices_map(c_graph, c_vertices.unwrap(), c_idx, c_invidx)

    # Prepare output arguments
    idx = igraph_vector_int_t_to_numpy_array(c_idx)
    invidx = igraph_vector_int_t_to_numpy_array(c_invidx)

    # Construct return value
    return idx, invidx


def vcount(graph: Graph) -> int:
    """Type-annotated wrapper for ``igraph_vcount``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    c__result = igraph_vcount(c_graph)

    # Construct return value
    return c__result


def ecount(graph: Graph) -> int:
    """Type-annotated wrapper for ``igraph_ecount``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    c__result = igraph_ecount(c_graph)

    # Construct return value
    return c__result


def neighbors(graph: Graph, vid: VertexLike, mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_neighbors``."""
    # Prepare input arguments
    c_graph = graph
    c_neis = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_neighbors(c_graph, c_neis, c_vid, c_mode)

    # Prepare output arguments
    neis = igraph_vector_int_t_to_numpy_array(c_neis)

    # Construct return value
    return neis


def is_directed(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_directed``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    c__result = igraph_is_directed(c_graph)

    # Construct return value
    return c__result


def degree(graph: Graph, loops: bool, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_degree(c_graph, c_res, c_vids.unwrap(), c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def edge(graph: Graph, eid: int) -> tuple[int, int]:
    """Type-annotated wrapper for ``igraph_edge``."""
    # Prepare input arguments
    c_graph = graph
    c_eid = eid
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()

    # Call wrapped function
    igraph_edge(c_graph, c_eid, c_from, c_to)

    # Prepare output arguments
    from_ = c_from.value
    to = c_to.value

    # Construct return value
    return from_, to


def edges(graph: Graph, eids: EdgeSelector) -> IntArray:
    """Type-annotated wrapper for ``igraph_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = edge_selector_to_igraph_es_t(eids, graph)
    c_edges = _VectorInt.create(0)

    # Call wrapped function
    igraph_edges(c_graph, c_eids.unwrap(), c_edges)

    # Prepare output arguments
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return edges


def get_eid(graph: Graph, from_: VertexLike, to: VertexLike, directed: bool = True, error: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_get_eid``."""
    # Prepare input arguments
    c_graph = graph
    c_eid = igraph_integer_t(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_directed = any_to_igraph_bool_t(directed)
    c_error = any_to_igraph_bool_t(error)

    # Call wrapped function
    igraph_get_eid(c_graph, c_eid, c_from, c_to, c_directed, c_error)

    # Prepare output arguments
    eid = c_eid.value

    # Construct return value
    return eid


def get_eids(graph: Graph, pairs: Iterable[VertexPair], directed: bool = True, error: bool = True) -> IntArray:
    """Type-annotated wrapper for ``igraph_get_eids``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = _VectorInt.create(0)
    c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
    c_directed = any_to_igraph_bool_t(directed)
    c_error = any_to_igraph_bool_t(error)

    # Call wrapped function
    igraph_get_eids(c_graph, c_eids, c_pairs, c_directed, c_error)

    # Prepare output arguments
    eids = igraph_vector_int_t_to_numpy_array(c_eids)

    # Construct return value
    return eids


def get_all_eids_between(graph: Graph, from_: VertexLike, to: VertexLike, directed: bool = True) -> IntArray:
    """Type-annotated wrapper for ``igraph_get_all_eids_between``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_get_all_eids_between(c_graph, c_eids, c_from, c_to, c_directed)

    # Prepare output arguments
    eids = igraph_vector_int_t_to_numpy_array(c_eids)

    # Construct return value
    return eids


def incident(graph: Graph, vid: VertexLike, mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_incident``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_incident(c_graph, c_eids, c_vid, c_mode)

    # Prepare output arguments
    eids = igraph_vector_int_t_to_numpy_array(c_eids)

    # Construct return value
    return eids


def is_same_graph(graph1: Graph, graph2: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_same_graph``."""
    # Prepare input arguments
    c_graph1 = graph1
    c_graph2 = graph2
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_same_graph(c_graph1, c_graph2, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def create(edges: Iterable[int], n: int = 0, directed: bool = True) -> Graph:
    """Creates a graph from the given edge list.

    Parameters:
        edges: the list of edges in the graph
        n: the number of vertices in the graph if it cannot be inferred from
            the maximum edge ID in the edge list

    Returns:
        the newly created graph
    """
    # Prepare input arguments
    c_graph = _Graph()
    c_edges = iterable_to_igraph_vector_int_t_view(edges)
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_create(c_graph, c_edges, c_n, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def adjacency(adjmatrix: MatrixLike, mode: AdjacencyMode = AdjacencyMode.DIRECTED, loops: Loops = Loops.ONCE) -> Graph:
    """Type-annotated wrapper for ``igraph_adjacency``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_adjmatrix = sequence_to_igraph_matrix_t_view(adjmatrix)
    c_mode = c_int(mode)
    c_loops = c_int(loops)

    # Call wrapped function
    igraph_adjacency(c_graph, c_adjmatrix, c_mode, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph

# igraph_sparse_adjacency: no Python type known for type: SPARSEMAT

# igraph_sparse_weighted_adjacency: no Python type known for type: SPARSEMAT


def weighted_adjacency(adjmatrix: MatrixLike, mode: AdjacencyMode = AdjacencyMode.DIRECTED, loops: Loops = Loops.ONCE) -> tuple[Graph, RealArray]:
    """Type-annotated wrapper for ``igraph_weighted_adjacency``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_adjmatrix = sequence_to_igraph_matrix_t_view(adjmatrix)
    c_mode = c_int(mode)
    c_weights = _Vector.create(0)
    c_loops = c_int(loops)

    # Call wrapped function
    igraph_weighted_adjacency(c_graph, c_adjmatrix, c_mode, c_weights, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    weights = igraph_vector_t_to_numpy_array(c_weights)

    # Construct return value
    return graph, weights


def star(n: int, mode: StarMode = StarMode.OUT, center: int = 0) -> Graph:
    """Type-annotated wrapper for ``igraph_star``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_mode = c_int(mode)
    c_center = center

    # Call wrapped function
    igraph_star(c_graph, c_n, c_mode, c_center)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def wheel(n: int, mode: WheelMode = WheelMode.OUT, center: int = 0) -> Graph:
    """Type-annotated wrapper for ``igraph_wheel``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_mode = c_int(mode)
    c_center = center

    # Call wrapped function
    igraph_wheel(c_graph, c_n, c_mode, c_center)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def square_lattice(dimvector: Iterable[int], nei: int = 1, directed: bool = False, mutual: bool = False, periodic: Optional[Iterable[bool]] = None) -> Graph:
    """Type-annotated wrapper for ``igraph_square_lattice``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_dimvector = iterable_to_igraph_vector_int_t_view(dimvector)
    c_nei = nei
    c_directed = any_to_igraph_bool_t(directed)
    c_mutual = any_to_igraph_bool_t(mutual)
    c_periodic = iterable_to_igraph_vector_bool_t_view(periodic) if periodic is not None else None

    # Call wrapped function
    igraph_square_lattice(c_graph, c_dimvector, c_nei, c_directed, c_mutual, c_periodic)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def triangular_lattice(dimvector: Iterable[int], directed: bool = False, mutual: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_triangular_lattice``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_dimvector = iterable_to_igraph_vector_int_t_view(dimvector)
    c_directed = any_to_igraph_bool_t(directed)
    c_mutual = any_to_igraph_bool_t(mutual)

    # Call wrapped function
    igraph_triangular_lattice(c_graph, c_dimvector, c_directed, c_mutual)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def ring(n: int, directed: bool = False, mutual: bool = False, circular: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_ring``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_mutual = any_to_igraph_bool_t(mutual)
    c_circular = any_to_igraph_bool_t(circular)

    # Call wrapped function
    igraph_ring(c_graph, c_n, c_directed, c_mutual, c_circular)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def kary_tree(n: int, children: int = 2, type: TreeMode = TreeMode.OUT) -> Graph:
    """Type-annotated wrapper for ``igraph_kary_tree``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_children = children
    c_type = c_int(type)

    # Call wrapped function
    igraph_kary_tree(c_graph, c_n, c_children, c_type)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def symmetric_tree(branches: Iterable[int], type: TreeMode = TreeMode.OUT) -> Graph:
    """Type-annotated wrapper for ``igraph_symmetric_tree``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_branches = iterable_to_igraph_vector_int_t_view(branches)
    c_type = c_int(type)

    # Call wrapped function
    igraph_symmetric_tree(c_graph, c_branches, c_type)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def regular_tree(h: int, k: int = 3, type: TreeMode = TreeMode.UNDIRECTED) -> Graph:
    """Type-annotated wrapper for ``igraph_regular_tree``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_h = h
    c_k = k
    c_type = c_int(type)

    # Call wrapped function
    igraph_regular_tree(c_graph, c_h, c_k, c_type)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def full(n: int, directed: bool = False, loops: bool = False) -> Graph:
    """Creates a full graph with the given number of vertices.

    Parameters:
        n: the number of vertices
        directed: whether the graph is directed
        loops: whether each vertex should also have a loop edge

    Returns:
        the newly created graph
    """
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_full(c_graph, c_n, c_directed, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def full_citation(n: int, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_full_citation``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_full_citation(c_graph, c_n, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def atlas(number: int = 0) -> Graph:
    """Type-annotated wrapper for ``igraph_atlas``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_number = number

    # Call wrapped function
    igraph_atlas(c_graph, c_number)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def extended_chordal_ring(nodes: int, W: MatrixIntLike, directed: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_extended_chordal_ring``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_W = sequence_to_igraph_matrix_int_t_view(W)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_extended_chordal_ring(c_graph, c_nodes, c_W, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def connect_neighborhood(graph: Graph, order: int = 2, mode: NeighborMode = NeighborMode.ALL) -> None:
    """Type-annotated wrapper for ``igraph_connect_neighborhood``."""
    # Prepare input arguments
    c_graph = graph
    c_order = order
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_connect_neighborhood(c_graph, c_order, c_mode)


def graph_power(graph: Graph, order: int, directed: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_graph_power``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_order = order
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_graph_power(c_graph, c_res, c_order, c_directed)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res


def linegraph(graph: Graph) -> Graph:
    """Type-annotated wrapper for ``igraph_linegraph``."""
    # Prepare input arguments
    c_graph = graph
    c_linegraph = _Graph()

    # Call wrapped function
    igraph_linegraph(c_graph, c_linegraph)

    # Prepare output arguments
    linegraph = _create_graph_from_boxed(c_linegraph)

    # Construct return value
    return linegraph


def de_bruijn(m: int, n: int) -> Graph:
    """Type-annotated wrapper for ``igraph_de_bruijn``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_m = m
    c_n = n

    # Call wrapped function
    igraph_de_bruijn(c_graph, c_m, c_n)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def kautz(m: int, n: int) -> Graph:
    """Type-annotated wrapper for ``igraph_kautz``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_m = m
    c_n = n

    # Call wrapped function
    igraph_kautz(c_graph, c_m, c_n)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def famous(name: str) -> Graph:
    """Creates one of the "famous" graphs embedded into igraph by name.

    See the documentation of the ``igraph_famous()`` function in igraph's C core
    for a list of names accepted by this function.

    Parameters:
        name: the name of the graph to construct

    Returns:
        the constructed graph
    """
    # Prepare input arguments
    c_graph = _Graph()
    c_name = name.encode("utf-8")

    # Call wrapped function
    igraph_famous(c_graph, c_name)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def lcf_vector(n: int, shifts: Iterable[int], repeats: int = 1) -> Graph:
    """Type-annotated wrapper for ``igraph_lcf_vector``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_shifts = iterable_to_igraph_vector_int_t_view(shifts)
    c_repeats = repeats

    # Call wrapped function
    igraph_lcf_vector(c_graph, c_n, c_shifts, c_repeats)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph

# igraph_adjlist: no Python type known for type: ADJLIST


def full_bipartite(n1: int, n2: int, directed: bool = False, mode: NeighborMode = NeighborMode.ALL) -> tuple[Graph, BoolArray]:
    """Type-annotated wrapper for ``igraph_full_bipartite``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorBool.create(0)
    c_n1 = n1
    c_n2 = n2
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_full_bipartite(c_graph, c_types, c_n1, c_n2, c_directed, c_mode)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = c_types.value

    # Construct return value
    return graph, types


def full_multipartite(n: Iterable[int], directed: bool = False, mode: NeighborMode = NeighborMode.ALL) -> tuple[Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_full_multipartite``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorInt.create(0)
    c_n = iterable_to_igraph_vector_int_t_view(n)
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_full_multipartite(c_graph, c_types, c_n, c_directed, c_mode)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = igraph_vector_int_t_to_numpy_array(c_types)

    # Construct return value
    return graph, types

# igraph_realize_degree_sequence: no Python type known for type: EDGE_TYPE_SW


def circulant(n: int, shifts: Iterable[int], directed: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_circulant``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_shifts = iterable_to_igraph_vector_int_t_view(shifts)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_circulant(c_graph, c_n, c_shifts, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def generalized_petersen(n: int, k: int) -> Graph:
    """Type-annotated wrapper for ``igraph_generalized_petersen``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_k = k

    # Call wrapped function
    igraph_generalized_petersen(c_graph, c_n, c_k)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def turan(n: int, r: int) -> tuple[Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_turan``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorInt.create(0)
    c_n = n
    c_r = r

    # Call wrapped function
    igraph_turan(c_graph, c_types, c_n, c_r)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = igraph_vector_int_t_to_numpy_array(c_types)

    # Construct return value
    return graph, types

# igraph_weighted_sparsemat: no Python type known for type: SPARSEMAT


def barabasi_game(n: int, power: float = 1.0, m: int = 1, outseq: Optional[Iterable[int]] = None, outpref: bool = False, A: float = 1.0, directed: bool = True, algo: BarabasiAlgorithm = BarabasiAlgorithm.BAG, start_from: Optional[Graph] = None) -> Graph:
    """Type-annotated wrapper for ``igraph_barabasi_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_power = power
    c_m = m
    c_outseq = iterable_to_igraph_vector_int_t_view(outseq) if outseq is not None else None
    c_outpref = any_to_igraph_bool_t(outpref)
    c_A = A
    c_directed = any_to_igraph_bool_t(directed)
    c_algo = c_int(algo)
    c_start_from = start_from if start_from is not None else None

    # Call wrapped function
    igraph_barabasi_game(c_graph, c_n, c_power, c_m, c_outseq, c_outpref, c_A, c_directed, c_algo, c_start_from)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def erdos_renyi_game_gnp(n: int, p: float, directed: bool = False, loops: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_erdos_renyi_game_gnp``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_p = p
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_erdos_renyi_game_gnp(c_graph, c_n, c_p, c_directed, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def erdos_renyi_game_gnm(n: int, m: int, directed: bool = False, loops: bool = False, multiple: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_erdos_renyi_game_gnm``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_m = m
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_erdos_renyi_game_gnm(c_graph, c_n, c_m, c_directed, c_loops, c_multiple)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def degree_sequence_game(out_deg: Iterable[int], in_deg: Optional[Iterable[int]] = None, method: DegreeSequenceMode = DegreeSequenceMode.CONFIGURATION) -> Graph:
    """Type-annotated wrapper for ``igraph_degree_sequence_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_out_deg = iterable_to_igraph_vector_int_t_view(out_deg)
    c_in_deg = iterable_to_igraph_vector_int_t_view(in_deg) if in_deg is not None else None
    c_method = c_int(method)

    # Call wrapped function
    igraph_degree_sequence_game(c_graph, c_out_deg, c_in_deg, c_method)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def growing_random_game(n: int, m: int = 1, directed: bool = False, citation: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_growing_random_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_m = m
    c_directed = any_to_igraph_bool_t(directed)
    c_citation = any_to_igraph_bool_t(citation)

    # Call wrapped function
    igraph_growing_random_game(c_graph, c_n, c_m, c_directed, c_citation)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def barabasi_aging_game(nodes: int, m: int = 1, outseq: Optional[Iterable[int]] = None, outpref: bool = False, pa_exp: float = 1.0, aging_exp: float = 0.0, aging_bin: int = 1, zero_deg_appeal: float = 1.0, zero_age_appeal: float = 0.0, deg_coef: float = 1.0, age_coef: float = 1.0, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_barabasi_aging_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_m = m
    c_outseq = iterable_to_igraph_vector_int_t_view(outseq) if outseq is not None else None
    c_outpref = any_to_igraph_bool_t(outpref)
    c_pa_exp = pa_exp
    c_aging_exp = aging_exp
    c_aging_bin = aging_bin
    c_zero_deg_appeal = zero_deg_appeal
    c_zero_age_appeal = zero_age_appeal
    c_deg_coef = deg_coef
    c_age_coef = age_coef
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_barabasi_aging_game(c_graph, c_nodes, c_m, c_outseq, c_outpref, c_pa_exp, c_aging_exp, c_aging_bin, c_zero_deg_appeal, c_zero_age_appeal, c_deg_coef, c_age_coef, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def recent_degree_game(n: int, power: float = 1.0, window: int = 1, m: int = 1, outseq: Optional[Iterable[int]] = None, outpref: bool = False, zero_appeal: float = 1.0, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_recent_degree_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_power = power
    c_window = window
    c_m = m
    c_outseq = iterable_to_igraph_vector_int_t_view(outseq) if outseq is not None else None
    c_outpref = any_to_igraph_bool_t(outpref)
    c_zero_appeal = zero_appeal
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_recent_degree_game(c_graph, c_n, c_power, c_window, c_m, c_outseq, c_outpref, c_zero_appeal, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def recent_degree_aging_game(nodes: int, m: int = 1, outseq: Optional[Iterable[int]] = None, outpref: bool = False, pa_exp: float = 1.0, aging_exp: float = 0.0, aging_bin: int = 1, window: int = 1, zero_appeal: float = 1.0, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_recent_degree_aging_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_m = m
    c_outseq = iterable_to_igraph_vector_int_t_view(outseq) if outseq is not None else None
    c_outpref = any_to_igraph_bool_t(outpref)
    c_pa_exp = pa_exp
    c_aging_exp = aging_exp
    c_aging_bin = aging_bin
    c_window = window
    c_zero_appeal = zero_appeal
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_recent_degree_aging_game(c_graph, c_nodes, c_m, c_outseq, c_outpref, c_pa_exp, c_aging_exp, c_aging_bin, c_window, c_zero_appeal, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def callaway_traits_game(nodes: int, types: int, type_dist: Iterable[float], pref_matrix: MatrixLike, edges_per_step: int = 1, directed: bool = False) -> tuple[Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_callaway_traits_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_types = types
    c_edges_per_step = edges_per_step
    c_type_dist = iterable_to_igraph_vector_t_view(type_dist)
    c_pref_matrix = sequence_to_igraph_matrix_t_view(pref_matrix)
    c_directed = any_to_igraph_bool_t(directed)
    c_node_type_vec = _VectorInt.create(0)

    # Call wrapped function
    igraph_callaway_traits_game(c_graph, c_nodes, c_types, c_edges_per_step, c_type_dist, c_pref_matrix, c_directed, c_node_type_vec)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    node_type_vec = igraph_vector_int_t_to_numpy_array(c_node_type_vec)

    # Construct return value
    return graph, node_type_vec


def establishment_game(nodes: int, types: int, type_dist: Iterable[float], pref_matrix: MatrixLike, k: int = 1, directed: bool = True) -> tuple[Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_establishment_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_types = types
    c_k = k
    c_type_dist = iterable_to_igraph_vector_t_view(type_dist)
    c_pref_matrix = sequence_to_igraph_matrix_t_view(pref_matrix)
    c_directed = any_to_igraph_bool_t(directed)
    c_node_type_vec = _VectorInt.create(0)

    # Call wrapped function
    igraph_establishment_game(c_graph, c_nodes, c_types, c_k, c_type_dist, c_pref_matrix, c_directed, c_node_type_vec)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    node_type_vec = igraph_vector_int_t_to_numpy_array(c_node_type_vec)

    # Construct return value
    return graph, node_type_vec


def grg_game(nodes: int, radius: float, torus: bool = False) -> tuple[Graph, RealArray, RealArray]:
    """Type-annotated wrapper for ``igraph_grg_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_radius = radius
    c_torus = any_to_igraph_bool_t(torus)
    c_x = _Vector.create(0)
    c_y = _Vector.create(0)

    # Call wrapped function
    igraph_grg_game(c_graph, c_nodes, c_radius, c_torus, c_x, c_y)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    x = igraph_vector_t_to_numpy_array(c_x)
    y = igraph_vector_t_to_numpy_array(c_y)

    # Construct return value
    return graph, x, y


def preference_game(nodes: int, types: int, type_dist: Iterable[float], pref_matrix: MatrixLike, fixed_sizes: bool = False, directed: bool = False, loops: bool = False) -> tuple[Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_preference_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_types = types
    c_type_dist = iterable_to_igraph_vector_t_view(type_dist)
    c_fixed_sizes = any_to_igraph_bool_t(fixed_sizes)
    c_pref_matrix = sequence_to_igraph_matrix_t_view(pref_matrix)
    c_node_type_vec = _VectorInt.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_preference_game(c_graph, c_nodes, c_types, c_type_dist, c_fixed_sizes, c_pref_matrix, c_node_type_vec, c_directed, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    node_type_vec = igraph_vector_int_t_to_numpy_array(c_node_type_vec)

    # Construct return value
    return graph, node_type_vec


def asymmetric_preference_game(nodes: int, out_types: int, in_types: int, type_dist_matrix: MatrixLike, pref_matrix: MatrixLike, loops: bool = False) -> tuple[Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_asymmetric_preference_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_out_types = out_types
    c_in_types = in_types
    c_type_dist_matrix = sequence_to_igraph_matrix_t_view(type_dist_matrix)
    c_pref_matrix = sequence_to_igraph_matrix_t_view(pref_matrix)
    c_node_type_out_vec = _VectorInt.create(0)
    c_node_type_in_vec = _VectorInt.create(0)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_asymmetric_preference_game(c_graph, c_nodes, c_out_types, c_in_types, c_type_dist_matrix, c_pref_matrix, c_node_type_out_vec, c_node_type_in_vec, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    node_type_out_vec = igraph_vector_int_t_to_numpy_array(c_node_type_out_vec)
    node_type_in_vec = igraph_vector_int_t_to_numpy_array(c_node_type_in_vec)

    # Construct return value
    return graph, node_type_out_vec, node_type_in_vec


def rewire_edges(graph: Graph, prob: float, loops: bool = False, multiple: bool = False) -> None:
    """Type-annotated wrapper for ``igraph_rewire_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_prob = prob
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_rewire_edges(c_graph, c_prob, c_loops, c_multiple)


def rewire_directed_edges(graph: Graph, prob: float, loops: bool = False, mode: NeighborMode = NeighborMode.OUT) -> None:
    """Type-annotated wrapper for ``igraph_rewire_directed_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_prob = prob
    c_loops = any_to_igraph_bool_t(loops)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_rewire_directed_edges(c_graph, c_prob, c_loops, c_mode)


def watts_strogatz_game(dim: int, size: int, nei: int, p: float, loops: bool = False, multiple: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_watts_strogatz_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_dim = dim
    c_size = size
    c_nei = nei
    c_p = p
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_watts_strogatz_game(c_graph, c_dim, c_size, c_nei, c_p, c_loops, c_multiple)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def lastcit_game(nodes: int, preference: Iterable[float], edges_per_node: int = 1, agebins: int = 1, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_lastcit_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_edges_per_node = edges_per_node
    c_agebins = agebins
    c_preference = iterable_to_igraph_vector_t_view(preference)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_lastcit_game(c_graph, c_nodes, c_edges_per_node, c_agebins, c_preference, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def cited_type_game(nodes: int, types: Iterable[int], pref: Iterable[float], edges_per_step: int = 1, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_cited_type_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_types = iterable_to_igraph_vector_int_t_view(types)
    c_pref = iterable_to_igraph_vector_t_view(pref)
    c_edges_per_step = edges_per_step
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_cited_type_game(c_graph, c_nodes, c_types, c_pref, c_edges_per_step, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def citing_cited_type_game(nodes: int, types: Iterable[int], pref: MatrixLike, edges_per_step: int = 1, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_citing_cited_type_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_types = iterable_to_igraph_vector_int_t_view(types)
    c_pref = sequence_to_igraph_matrix_t_view(pref)
    c_edges_per_step = edges_per_step
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_citing_cited_type_game(c_graph, c_nodes, c_types, c_pref, c_edges_per_step, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def forest_fire_game(nodes: int, fw_prob: float, bw_factor: float = 1, ambs: int = 1, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_forest_fire_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_fw_prob = fw_prob
    c_bw_factor = bw_factor
    c_ambs = ambs
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_forest_fire_game(c_graph, c_nodes, c_fw_prob, c_bw_factor, c_ambs, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def simple_interconnected_islands_game(islands_n: int, islands_size: int, islands_pin: float, n_inter: int) -> Graph:
    """Type-annotated wrapper for ``igraph_simple_interconnected_islands_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_islands_n = islands_n
    c_islands_size = islands_size
    c_islands_pin = islands_pin
    c_n_inter = n_inter

    # Call wrapped function
    igraph_simple_interconnected_islands_game(c_graph, c_islands_n, c_islands_size, c_islands_pin, c_n_inter)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def static_fitness_game(no_of_edges: int, fitness_out: Iterable[float], fitness_in: Optional[Iterable[float]] = None, loops: bool = False, multiple: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_static_fitness_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_no_of_edges = no_of_edges
    c_fitness_out = iterable_to_igraph_vector_t_view(fitness_out)
    c_fitness_in = iterable_to_igraph_vector_t_view(fitness_in) if fitness_in is not None else None
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_static_fitness_game(c_graph, c_no_of_edges, c_fitness_out, c_fitness_in, c_loops, c_multiple)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def static_power_law_game(no_of_nodes: int, no_of_edges: int, exponent_out: float, exponent_in: float = -1, loops: bool = False, multiple: bool = False, finite_size_correction: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_static_power_law_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_no_of_nodes = no_of_nodes
    c_no_of_edges = no_of_edges
    c_exponent_out = exponent_out
    c_exponent_in = exponent_in
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)
    c_finite_size_correction = any_to_igraph_bool_t(finite_size_correction)

    # Call wrapped function
    igraph_static_power_law_game(c_graph, c_no_of_nodes, c_no_of_edges, c_exponent_out, c_exponent_in, c_loops, c_multiple, c_finite_size_correction)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def k_regular_game(no_of_nodes: int, k: int, directed: bool = False, multiple: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_k_regular_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_no_of_nodes = no_of_nodes
    c_k = k
    c_directed = any_to_igraph_bool_t(directed)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_k_regular_game(c_graph, c_no_of_nodes, c_k, c_directed, c_multiple)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def sbm_game(n: int, pref_matrix: MatrixLike, block_sizes: Iterable[int], directed: bool = False, loops: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_sbm_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_pref_matrix = sequence_to_igraph_matrix_t_view(pref_matrix)
    c_block_sizes = iterable_to_igraph_vector_int_t_view(block_sizes)
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_sbm_game(c_graph, c_n, c_pref_matrix, c_block_sizes, c_directed, c_loops)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def hsbm_game(n: int, m: int, rho: Iterable[float], C: MatrixLike, p: float) -> Graph:
    """Type-annotated wrapper for ``igraph_hsbm_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_m = m
    c_rho = iterable_to_igraph_vector_t_view(rho)
    c_C = sequence_to_igraph_matrix_t_view(C)
    c_p = p

    # Call wrapped function
    igraph_hsbm_game(c_graph, c_n, c_m, c_rho, c_C, c_p)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph

# igraph_hsbm_list_game: no Python type known for type: VECTOR_LIST


def dot_product_game(vecs: MatrixLike, directed: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_dot_product_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_vecs = sequence_to_igraph_matrix_t_view(vecs)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_dot_product_game(c_graph, c_vecs, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def sample_sphere_surface(dim: int, n: int = 1, radius: float = 1, positive: bool = True) -> RealArray:
    """Type-annotated wrapper for ``igraph_sample_sphere_surface``."""
    # Prepare input arguments
    c_dim = dim
    c_n = n
    c_radius = radius
    c_positive = any_to_igraph_bool_t(positive)
    c_res = _Matrix.create(0)

    # Call wrapped function
    igraph_sample_sphere_surface(c_dim, c_n, c_radius, c_positive, c_res)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def sample_sphere_volume(dim: int, n: int = 1, radius: float = 1, positive: bool = True) -> RealArray:
    """Type-annotated wrapper for ``igraph_sample_sphere_volume``."""
    # Prepare input arguments
    c_dim = dim
    c_n = n
    c_radius = radius
    c_positive = any_to_igraph_bool_t(positive)
    c_res = _Matrix.create(0)

    # Call wrapped function
    igraph_sample_sphere_volume(c_dim, c_n, c_radius, c_positive, c_res)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def sample_dirichlet(n: int, alpha: Iterable[float]) -> RealArray:
    """Type-annotated wrapper for ``igraph_sample_dirichlet``."""
    # Prepare input arguments
    c_n = n
    c_alpha = iterable_to_igraph_vector_t_view(alpha)
    c_res = _Matrix.create(0)

    # Call wrapped function
    igraph_sample_dirichlet(c_n, c_alpha, c_res)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def are_connected(graph: Graph, v1: VertexLike, v2: VertexLike) -> bool:
    """Type-annotated wrapper for ``igraph_are_connected``."""
    # Prepare input arguments
    c_graph = graph
    c_v1 = vertexlike_to_igraph_integer_t(v1)
    c_v2 = vertexlike_to_igraph_integer_t(v2)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_are_connected(c_graph, c_v1, c_v2, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def diameter(graph: Graph, directed: bool = True, unconnected: bool = True) -> tuple[float, int, int, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_diameter``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()
    c_vertex_path = _VectorInt.create(0)
    c_edge_path = _VectorInt.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_unconnected = any_to_igraph_bool_t(unconnected)

    # Call wrapped function
    igraph_diameter(c_graph, c_res, c_from, c_to, c_vertex_path, c_edge_path, c_directed, c_unconnected)

    # Prepare output arguments
    res = c_res.value
    from_ = c_from.value
    to = c_to.value
    vertex_path = igraph_vector_int_t_to_numpy_array(c_vertex_path)
    edge_path = igraph_vector_int_t_to_numpy_array(c_edge_path)

    # Construct return value
    return res, from_, to, vertex_path, edge_path


def diameter_dijkstra(graph: Graph, weights: Optional[Iterable[float]] = None, directed: bool = True, unconnected: bool = True) -> tuple[float, int, int, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_diameter_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_res = igraph_real_t()
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()
    c_vertex_path = _VectorInt.create(0)
    c_edge_path = _VectorInt.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_unconnected = any_to_igraph_bool_t(unconnected)

    # Call wrapped function
    igraph_diameter_dijkstra(c_graph, c_weights, c_res, c_from, c_to, c_vertex_path, c_edge_path, c_directed, c_unconnected)

    # Prepare output arguments
    res = c_res.value
    from_ = c_from.value
    to = c_to.value
    vertex_path = igraph_vector_int_t_to_numpy_array(c_vertex_path)
    edge_path = igraph_vector_int_t_to_numpy_array(c_edge_path)

    # Construct return value
    return res, from_, to, vertex_path, edge_path


def closeness(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT, weights: Optional[Iterable[float]] = None, normalized: bool = False) -> tuple[RealArray, IntArray, bool]:
    """Type-annotated wrapper for ``igraph_closeness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_reachable_count = _VectorInt.create(0)
    c_all_reachable = igraph_bool_t()
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_closeness(c_graph, c_res, c_reachable_count, c_all_reachable, c_vids.unwrap(), c_mode, c_weights, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    reachable_count = igraph_vector_int_t_to_numpy_array(c_reachable_count)
    all_reachable = c_all_reachable.value

    # Construct return value
    return res, reachable_count, all_reachable


def closeness_cutoff(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT, weights: Optional[Iterable[float]] = None, normalized: bool = False, cutoff: float = -1) -> tuple[RealArray, IntArray, bool]:
    """Type-annotated wrapper for ``igraph_closeness_cutoff``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_reachable_count = _VectorInt.create(0)
    c_all_reachable = igraph_bool_t()
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_normalized = any_to_igraph_bool_t(normalized)
    c_cutoff = cutoff

    # Call wrapped function
    igraph_closeness_cutoff(c_graph, c_res, c_reachable_count, c_all_reachable, c_vids.unwrap(), c_mode, c_weights, c_normalized, c_cutoff)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    reachable_count = igraph_vector_int_t_to_numpy_array(c_reachable_count)
    all_reachable = c_all_reachable.value

    # Construct return value
    return res, reachable_count, all_reachable


def distances(graph: Graph, from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_distances(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def distances_cutoff(graph: Graph, from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT, cutoff: float = -1) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances_cutoff``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_mode = c_int(mode)
    c_cutoff = cutoff

    # Call wrapped function
    igraph_distances_cutoff(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_mode, c_cutoff)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def get_shortest_path(graph: Graph, from_: VertexLike, to: VertexLike, mode: NeighborMode = NeighborMode.OUT) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_shortest_path``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorInt.create(0)
    c_edges = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_shortest_path(c_graph, c_vertices, c_edges, c_from, c_to, c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return vertices, edges


def get_shortest_path_bellman_ford(graph: Graph, from_: VertexLike, to: VertexLike, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_shortest_path_bellman_ford``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorInt.create(0)
    c_edges = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_shortest_path_bellman_ford(c_graph, c_vertices, c_edges, c_from, c_to, c_weights, c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return vertices, edges


def get_shortest_path_dijkstra(graph: Graph, from_: VertexLike, to: VertexLike, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_shortest_path_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorInt.create(0)
    c_edges = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_shortest_path_dijkstra(c_graph, c_vertices, c_edges, c_from, c_to, c_weights, c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return vertices, edges


def get_shortest_paths(graph: Graph, from_: VertexLike, to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray], IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_shortest_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorIntList.create(0)
    c_edges = _VectorIntList.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_mode = c_int(mode)
    c_parents = _VectorInt.create(0)
    c_inbound_edges = _VectorInt.create(0)

    # Call wrapped function
    igraph_get_shortest_paths(c_graph, c_vertices, c_edges, c_from, c_to.unwrap(), c_mode, c_parents, c_inbound_edges)

    # Prepare output arguments
    vertices = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertices)
    edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_edges)
    parents = igraph_vector_int_t_to_numpy_array(c_parents)
    inbound_edges = igraph_vector_int_t_to_numpy_array(c_inbound_edges)

    # Construct return value
    return vertices, edges, parents, inbound_edges


def get_all_shortest_paths(graph: Graph, from_: VertexLike, to: VertexSelector, mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray], IntArray]:
    """Type-annotated wrapper for ``igraph_get_all_shortest_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorIntList.create(0)
    c_edges = _VectorIntList.create(0)
    c_nrgeo = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_all_shortest_paths(c_graph, c_vertices, c_edges, c_nrgeo, c_from, c_to.unwrap(), c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertices)
    edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_edges)
    nrgeo = igraph_vector_int_t_to_numpy_array(c_nrgeo)

    # Construct return value
    return vertices, edges, nrgeo


def distances_dijkstra(graph: Graph, weights: Iterable[float], from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_distances_dijkstra(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def distances_dijkstra_cutoff(graph: Graph, weights: Iterable[float], from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT, cutoff: float = -1) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances_dijkstra_cutoff``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)
    c_cutoff = cutoff

    # Call wrapped function
    igraph_distances_dijkstra_cutoff(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode, c_cutoff)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def get_shortest_paths_dijkstra(graph: Graph, from_: VertexLike, to: VertexSelector = "all", weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray], IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_shortest_paths_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorIntList.create(0)
    c_edges = _VectorIntList.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)
    c_parents = _VectorInt.create(0)
    c_inbound_edges = _VectorInt.create(0)

    # Call wrapped function
    igraph_get_shortest_paths_dijkstra(c_graph, c_vertices, c_edges, c_from, c_to.unwrap(), c_weights, c_mode, c_parents, c_inbound_edges)

    # Prepare output arguments
    vertices = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertices)
    edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_edges)
    parents = igraph_vector_int_t_to_numpy_array(c_parents)
    inbound_edges = igraph_vector_int_t_to_numpy_array(c_inbound_edges)

    # Construct return value
    return vertices, edges, parents, inbound_edges


def get_shortest_paths_bellman_ford(graph: Graph, from_: VertexLike, to: VertexSelector = "all", weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray], IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_shortest_paths_bellman_ford``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorIntList.create(0)
    c_edges = _VectorIntList.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)
    c_parents = _VectorInt.create(0)
    c_inbound_edges = _VectorInt.create(0)

    # Call wrapped function
    igraph_get_shortest_paths_bellman_ford(c_graph, c_vertices, c_edges, c_from, c_to.unwrap(), c_weights, c_mode, c_parents, c_inbound_edges)

    # Prepare output arguments
    vertices = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertices)
    edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_edges)
    parents = igraph_vector_int_t_to_numpy_array(c_parents)
    inbound_edges = igraph_vector_int_t_to_numpy_array(c_inbound_edges)

    # Construct return value
    return vertices, edges, parents, inbound_edges


def get_all_shortest_paths_dijkstra(graph: Graph, from_: VertexLike, weights: Iterable[float], to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray], IntArray]:
    """Type-annotated wrapper for ``igraph_get_all_shortest_paths_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorIntList.create(0)
    c_edges = _VectorIntList.create(0)
    c_nrgeo = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_all_shortest_paths_dijkstra(c_graph, c_vertices, c_edges, c_nrgeo, c_from, c_to.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertices)
    edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_edges)
    nrgeo = igraph_vector_int_t_to_numpy_array(c_nrgeo)

    # Construct return value
    return vertices, edges, nrgeo


def distances_bellman_ford(graph: Graph, weights: Iterable[float], from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances_bellman_ford``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_distances_bellman_ford(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def distances_johnson(graph: Graph, from_: VertexSelector = "all", to: VertexSelector = "all", weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances_johnson``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_distances_johnson(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def distances_floyd_warshall(graph: Graph, method: FloydWarshallAlgorithm, from_: VertexSelector = "all", to: VertexSelector = "all", weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_distances_floyd_warshall``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)
    c_method = c_int(method)

    # Call wrapped function
    igraph_distances_floyd_warshall(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode, c_method)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def voronoi(graph: Graph, generators: Iterable[VertexLike], weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT, tiebreaker: VoronoiTiebreaker = VoronoiTiebreaker.RANDOM) -> tuple[IntArray, RealArray]:
    """Type-annotated wrapper for ``igraph_voronoi``."""
    # Prepare input arguments
    c_graph = graph
    c_membership = _VectorInt.create(0)
    c_distances = _Vector.create(0)
    c_generators = iterable_vertex_indices_to_igraph_vector_int_t(generators)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)
    c_tiebreaker = c_int(tiebreaker)

    # Call wrapped function
    igraph_voronoi(c_graph, c_membership, c_distances, c_generators, c_weights, c_mode, c_tiebreaker)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    distances = igraph_vector_t_to_numpy_array(c_distances)

    # Construct return value
    return membership, distances


def get_all_simple_paths(graph: Graph, from_: VertexLike, to: VertexSelector = "all", cutoff: int = -1, mode: NeighborMode = NeighborMode.OUT) -> IntArray:
    """Type-annotated wrapper for ``igraph_get_all_simple_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_cutoff = cutoff
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_all_simple_paths(c_graph, c_res, c_from, c_to.unwrap(), c_cutoff, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def get_k_shortest_paths(graph: Graph, k: int, from_: VertexLike, to: VertexLike, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray]]:
    """Type-annotated wrapper for ``igraph_get_k_shortest_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_vertex_paths = _VectorIntList.create(0)
    c_edge_paths = _VectorIntList.create(0)
    c_k = k
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_k_shortest_paths(c_graph, c_weights, c_vertex_paths, c_edge_paths, c_k, c_from, c_to, c_mode)

    # Prepare output arguments
    vertex_paths = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertex_paths)
    edge_paths = igraph_vector_int_list_t_to_list_of_numpy_array(c_edge_paths)

    # Construct return value
    return vertex_paths, edge_paths


def get_widest_path(graph: Graph, from_: VertexLike, to: VertexLike, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_widest_path``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorInt.create(0)
    c_edges = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_widest_path(c_graph, c_vertices, c_edges, c_from, c_to, c_weights, c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return vertices, edges


def get_widest_paths(graph: Graph, from_: VertexLike, to: VertexSelector = "all", weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> tuple[list[IntArray], list[IntArray], IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_widest_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorIntList.create(0)
    c_edges = _VectorIntList.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)
    c_parents = _VectorInt.create(0)
    c_inbound_edges = _VectorInt.create(0)

    # Call wrapped function
    igraph_get_widest_paths(c_graph, c_vertices, c_edges, c_from, c_to.unwrap(), c_weights, c_mode, c_parents, c_inbound_edges)

    # Prepare output arguments
    vertices = igraph_vector_int_list_t_to_list_of_numpy_array(c_vertices)
    edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_edges)
    parents = igraph_vector_int_t_to_numpy_array(c_parents)
    inbound_edges = igraph_vector_int_t_to_numpy_array(c_inbound_edges)

    # Construct return value
    return vertices, edges, parents, inbound_edges


def widest_path_widths_dijkstra(graph: Graph, weights: Iterable[float], from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_widest_path_widths_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_widest_path_widths_dijkstra(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def widest_path_widths_floyd_warshall(graph: Graph, weights: Iterable[float], from_: VertexSelector = "all", to: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_widest_path_widths_floyd_warshall``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_from = vertex_selector_to_igraph_vs_t(from_, graph)
    c_to = vertex_selector_to_igraph_vs_t(to, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_widest_path_widths_floyd_warshall(c_graph, c_res, c_from.unwrap(), c_to.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def spanner(graph: Graph, stretch: float, weights: Iterable[float]) -> IntArray:
    """Type-annotated wrapper for ``igraph_spanner``."""
    # Prepare input arguments
    c_graph = graph
    c_spanner = _VectorInt.create(0)
    c_stretch = stretch
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_spanner(c_graph, c_spanner, c_stretch, c_weights)

    # Prepare output arguments
    spanner = igraph_vector_int_t_to_numpy_array(c_spanner)

    # Construct return value
    return spanner


def subcomponent(graph: Graph, vid: VertexLike, mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_subcomponent``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_subcomponent(c_graph, c_res, c_vid, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def betweenness(graph: Graph, vids: VertexSelector = "all", directed: bool = True, weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_betweenness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_betweenness(c_graph, c_res, c_vids.unwrap(), c_directed, c_weights)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def betweenness_cutoff(graph: Graph, vids: VertexSelector = "all", directed: bool = True, weights: Optional[Iterable[float]] = None, cutoff: float = -1) -> RealArray:
    """Type-annotated wrapper for ``igraph_betweenness_cutoff``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_cutoff = cutoff

    # Call wrapped function
    igraph_betweenness_cutoff(c_graph, c_res, c_vids.unwrap(), c_directed, c_weights, c_cutoff)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def betweenness_subset(graph: Graph, vids: VertexSelector = "all", directed: bool = True, sources: VertexSelector = "all", targets: VertexSelector = "all", weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_betweenness_subset``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_sources = vertex_selector_to_igraph_vs_t(sources, graph)
    c_targets = vertex_selector_to_igraph_vs_t(targets, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_betweenness_subset(c_graph, c_res, c_vids.unwrap(), c_directed, c_sources.unwrap(), c_targets.unwrap(), c_weights)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def edge_betweenness(graph: Graph, directed: bool = True, weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_edge_betweenness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_edge_betweenness(c_graph, c_res, c_directed, c_weights)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def edge_betweenness_cutoff(graph: Graph, directed: bool = True, weights: Optional[Iterable[float]] = None, cutoff: float = -1) -> RealArray:
    """Type-annotated wrapper for ``igraph_edge_betweenness_cutoff``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_cutoff = cutoff

    # Call wrapped function
    igraph_edge_betweenness_cutoff(c_graph, c_res, c_directed, c_weights, c_cutoff)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def edge_betweenness_subset(graph: Graph, eids: EdgeSelector = "all", directed: bool = True, sources: VertexSelector = "all", targets: VertexSelector = "all", weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_edge_betweenness_subset``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_eids = edge_selector_to_igraph_es_t(eids, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_sources = vertex_selector_to_igraph_vs_t(sources, graph)
    c_targets = vertex_selector_to_igraph_vs_t(targets, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_edge_betweenness_subset(c_graph, c_res, c_eids.unwrap(), c_directed, c_sources.unwrap(), c_targets.unwrap(), c_weights)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def harmonic_centrality(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT, weights: Optional[Iterable[float]] = None, normalized: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_harmonic_centrality``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_harmonic_centrality(c_graph, c_res, c_vids.unwrap(), c_mode, c_weights, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def harmonic_centrality_cutoff(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.OUT, weights: Optional[Iterable[float]] = None, normalized: bool = False, cutoff: float = -1) -> RealArray:
    """Type-annotated wrapper for ``igraph_harmonic_centrality_cutoff``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_normalized = any_to_igraph_bool_t(normalized)
    c_cutoff = cutoff

    # Call wrapped function
    igraph_harmonic_centrality_cutoff(c_graph, c_res, c_vids.unwrap(), c_mode, c_weights, c_normalized, c_cutoff)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_pagerank: no Python type known for type: PAGERANKOPT

# igraph_personalized_pagerank: no Python type known for type: PAGERANKOPT

# igraph_personalized_pagerank_vs: no Python type known for type: PAGERANKOPT


def rewire(rewire: Graph, n: int, mode: Rewiring = Rewiring.SIMPLE) -> None:
    """Type-annotated wrapper for ``igraph_rewire``."""
    # Prepare input arguments
    c_rewire = rewire
    c_n = n
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_rewire(c_rewire, c_n, c_mode)


def induced_subgraph(graph: Graph, vids: VertexSelector, impl: SubgraphImplementation = SubgraphImplementation.AUTO) -> Graph:
    """Type-annotated wrapper for ``igraph_induced_subgraph``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_impl = c_int(impl)

    # Call wrapped function
    igraph_induced_subgraph(c_graph, c_res, c_vids.unwrap(), c_impl)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res


def subgraph_from_edges(graph: Graph, eids: EdgeSelector, delete_vertices: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_subgraph_from_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_eids = edge_selector_to_igraph_es_t(eids, graph)
    c_delete_vertices = any_to_igraph_bool_t(delete_vertices)

    # Call wrapped function
    igraph_subgraph_from_edges(c_graph, c_res, c_eids.unwrap(), c_delete_vertices)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res


def reverse_edges(graph: Graph, eids: EdgeSelector = "all") -> None:
    """Type-annotated wrapper for ``igraph_reverse_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = edge_selector_to_igraph_es_t(eids, graph)

    # Call wrapped function
    igraph_reverse_edges(c_graph, c_eids.unwrap())


def average_path_length(graph: Graph, directed: bool = True, unconn: bool = True) -> tuple[float, float]:
    """Type-annotated wrapper for ``igraph_average_path_length``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_unconn_pairs = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_unconn = any_to_igraph_bool_t(unconn)

    # Call wrapped function
    igraph_average_path_length(c_graph, c_res, c_unconn_pairs, c_directed, c_unconn)

    # Prepare output arguments
    res = c_res.value
    unconn_pairs = c_unconn_pairs.value

    # Construct return value
    return res, unconn_pairs


def average_path_length_dijkstra(graph: Graph, weights: Optional[Iterable[float]] = None, directed: bool = True, unconn: bool = True) -> tuple[float, float]:
    """Type-annotated wrapper for ``igraph_average_path_length_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_unconn_pairs = igraph_real_t()
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_unconn = any_to_igraph_bool_t(unconn)

    # Call wrapped function
    igraph_average_path_length_dijkstra(c_graph, c_res, c_unconn_pairs, c_weights, c_directed, c_unconn)

    # Prepare output arguments
    res = c_res.value
    unconn_pairs = c_unconn_pairs.value

    # Construct return value
    return res, unconn_pairs


def path_length_hist(graph: Graph, directed: bool = True) -> tuple[RealArray, float]:
    """Type-annotated wrapper for ``igraph_path_length_hist``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_unconnected = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_path_length_hist(c_graph, c_res, c_unconnected, c_directed)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    unconnected = c_unconnected.value

    # Construct return value
    return res, unconnected


def simplify(graph: Graph, remove_multiple: bool = True, remove_loops: bool = True, edge_attr_comb: Optional[AttributeCombinationSpecification] = None) -> None:
    """Type-annotated wrapper for ``igraph_simplify``."""
    # Prepare input arguments
    c_graph = graph
    c_remove_multiple = any_to_igraph_bool_t(remove_multiple)
    c_remove_loops = any_to_igraph_bool_t(remove_loops)
    c_edge_attr_comb = mapping_to_attribute_combination_t(edge_attr_comb)

    # Call wrapped function
    igraph_simplify(c_graph, c_remove_multiple, c_remove_loops, c_edge_attr_comb)


def transitivity_undirected(graph: Graph, mode: TransitivityMode = TransitivityMode.NAN) -> float:
    """Type-annotated wrapper for ``igraph_transitivity_undirected``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_transitivity_undirected(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def transitivity_local_undirected(graph: Graph, vids: VertexSelector = "all", mode: TransitivityMode = TransitivityMode.NAN) -> RealArray:
    """Type-annotated wrapper for ``igraph_transitivity_local_undirected``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_transitivity_local_undirected(c_graph, c_res, c_vids.unwrap(), c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def transitivity_avglocal_undirected(graph: Graph, mode: TransitivityMode = TransitivityMode.NAN) -> float:
    """Type-annotated wrapper for ``igraph_transitivity_avglocal_undirected``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_transitivity_avglocal_undirected(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def transitivity_barrat(graph: Graph, vids: VertexSelector = "all", weights: Optional[Iterable[float]] = None, mode: TransitivityMode = TransitivityMode.NAN) -> RealArray:
    """Type-annotated wrapper for ``igraph_transitivity_barrat``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_transitivity_barrat(c_graph, c_res, c_vids.unwrap(), c_weights, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def ecc(graph: Graph, eids: EdgeSelector = "all", k: int = 3, offset: bool = False, normalize: bool = True) -> RealArray:
    """Type-annotated wrapper for ``igraph_ecc``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_eids = edge_selector_to_igraph_es_t(eids, graph)
    c_k = k
    c_offset = any_to_igraph_bool_t(offset)
    c_normalize = any_to_igraph_bool_t(normalize)

    # Call wrapped function
    igraph_ecc(c_graph, c_res, c_eids.unwrap(), c_k, c_offset, c_normalize)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def reciprocity(graph: Graph, ignore_loops: bool = True, mode: Reciprocity = Reciprocity.DEFAULT) -> float:
    """Type-annotated wrapper for ``igraph_reciprocity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_ignore_loops = any_to_igraph_bool_t(ignore_loops)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_reciprocity(c_graph, c_res, c_ignore_loops, c_mode)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def constraint(graph: Graph, vids: VertexSelector = "all", weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_constraint``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None

    # Call wrapped function
    igraph_constraint(c_graph, c_res, c_vids.unwrap(), c_weights)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def maxdegree(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_maxdegree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_maxdegree(c_graph, c_res, c_vids.unwrap(), c_mode, c_loops)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def density(graph: Graph, loops: bool = False) -> float:
    """Type-annotated wrapper for ``igraph_density``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_density(c_graph, c_res, c_loops)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def neighborhood_size(graph: Graph, vids: VertexSelector, order: int, mode: NeighborMode = NeighborMode.ALL, mindist: int = 0) -> IntArray:
    """Type-annotated wrapper for ``igraph_neighborhood_size``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_order = order
    c_mode = c_int(mode)
    c_mindist = mindist

    # Call wrapped function
    igraph_neighborhood_size(c_graph, c_res, c_vids.unwrap(), c_order, c_mode, c_mindist)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def neighborhood(graph: Graph, vids: VertexSelector, order: int, mode: NeighborMode = NeighborMode.ALL, mindist: int = 0) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_neighborhood``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_order = order
    c_mode = c_int(mode)
    c_mindist = mindist

    # Call wrapped function
    igraph_neighborhood(c_graph, c_res, c_vids.unwrap(), c_order, c_mode, c_mindist)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res

# igraph_neighborhood_graphs: no Python type known for type: GRAPH_LIST


def topological_sorting(graph: Graph, mode: NeighborMode = NeighborMode.OUT) -> IntArray:
    """Type-annotated wrapper for ``igraph_topological_sorting``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_topological_sorting(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def feedback_arc_set(graph: Graph, weights: Optional[Iterable[float]] = None, algo: FeedbackArcSetAlgorithm = FeedbackArcSetAlgorithm.APPROX_EADES) -> IntArray:
    """Type-annotated wrapper for ``igraph_feedback_arc_set``."""
    # Prepare input arguments
    c_graph = graph
    c_result = _VectorInt.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_algo = c_int(algo)

    # Call wrapped function
    igraph_feedback_arc_set(c_graph, c_result, c_weights, c_algo)

    # Prepare output arguments
    result = igraph_vector_int_t_to_numpy_array(c_result)

    # Construct return value
    return result


def is_loop(graph: Graph, es: EdgeSelector = "all") -> BoolArray:
    """Type-annotated wrapper for ``igraph_is_loop``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorBool.create(0)
    c_es = edge_selector_to_igraph_es_t(es, graph)

    # Call wrapped function
    igraph_is_loop(c_graph, c_res, c_es.unwrap())

    # Prepare output arguments
    res = igraph_vector_bool_t_to_numpy_array(c_res)

    # Construct return value
    return res


def is_dag(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_dag``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_dag(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_acyclic(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_acyclic``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_acyclic(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_simple(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_simple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_simple(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_multiple(graph: Graph, es: EdgeSelector = "all") -> BoolArray:
    """Type-annotated wrapper for ``igraph_is_multiple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorBool.create(0)
    c_es = edge_selector_to_igraph_es_t(es, graph)

    # Call wrapped function
    igraph_is_multiple(c_graph, c_res, c_es.unwrap())

    # Prepare output arguments
    res = igraph_vector_bool_t_to_numpy_array(c_res)

    # Construct return value
    return res


def has_loop(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_has_loop``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_has_loop(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def has_multiple(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_has_multiple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_has_multiple(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def count_multiple(graph: Graph, es: EdgeSelector = "all") -> IntArray:
    """Type-annotated wrapper for ``igraph_count_multiple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_es = edge_selector_to_igraph_es_t(es, graph)

    # Call wrapped function
    igraph_count_multiple(c_graph, c_res, c_es.unwrap())

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def girth(graph: Graph) -> tuple[float, IntArray]:
    """Type-annotated wrapper for ``igraph_girth``."""
    # Prepare input arguments
    c_graph = graph
    c_girth = igraph_real_t()
    c_circle = _VectorInt.create(0)

    # Call wrapped function
    igraph_girth(c_graph, c_girth, c_circle)

    # Prepare output arguments
    girth = c_girth.value
    circle = igraph_vector_int_t_to_numpy_array(c_circle)

    # Construct return value
    return girth, circle


def is_perfect(graph: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_perfect``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_perfect(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def add_edge(graph: Graph, from_: int, to: int) -> None:
    """Type-annotated wrapper for ``igraph_add_edge``."""
    # Prepare input arguments
    c_graph = graph
    c_from = from_
    c_to = to

    # Call wrapped function
    igraph_add_edge(c_graph, c_from, c_to)

# igraph_eigenvector_centrality: no Python type known for type: ARPACK_OPTIONS

# igraph_hub_score: no Python type known for type: ARPACK_OPTIONS

# igraph_authority_score: no Python type known for type: ARPACK_OPTIONS

# igraph_hub_and_authority_scores: no Python type known for type: ARPACK_OPTIONS


def unfold_tree(graph: Graph, roots: Iterable[int], mode: NeighborMode = NeighborMode.ALL) -> tuple[Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_unfold_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_tree = _Graph()
    c_mode = c_int(mode)
    c_roots = iterable_to_igraph_vector_int_t_view(roots)
    c_vertex_index = _VectorInt.create(0)

    # Call wrapped function
    igraph_unfold_tree(c_graph, c_tree, c_mode, c_roots, c_vertex_index)

    # Prepare output arguments
    tree = _create_graph_from_boxed(c_tree)
    vertex_index = igraph_vector_int_t_to_numpy_array(c_vertex_index)

    # Construct return value
    return tree, vertex_index


def is_mutual(graph: Graph, es: EdgeSelector = "all", loops: bool = True) -> BoolArray:
    """Type-annotated wrapper for ``igraph_is_mutual``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorBool.create(0)
    c_es = edge_selector_to_igraph_es_t(es, graph)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_is_mutual(c_graph, c_res, c_es.unwrap(), c_loops)

    # Prepare output arguments
    res = igraph_vector_bool_t_to_numpy_array(c_res)

    # Construct return value
    return res


def has_mutual(graph: Graph, loops: bool = True) -> bool:
    """Type-annotated wrapper for ``igraph_has_mutual``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_has_mutual(c_graph, c_res, c_loops)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def maximum_cardinality_search(graph: Graph) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_maximum_cardinality_search``."""
    # Prepare input arguments
    c_graph = graph
    c_alpha = _VectorInt.create(0)
    c_alpham1 = _VectorInt.create(0)

    # Call wrapped function
    igraph_maximum_cardinality_search(c_graph, c_alpha, c_alpham1)

    # Prepare output arguments
    alpha = igraph_vector_int_t_to_numpy_array(c_alpha)
    alpham1 = igraph_vector_int_t_to_numpy_array(c_alpham1)

    # Construct return value
    return alpha, alpham1


def is_chordal(graph: Graph, alpha: Optional[Iterable[int]] = None, alpham1: Optional[Iterable[VertexLike]] = None) -> tuple[bool, IntArray, Graph]:
    """Type-annotated wrapper for ``igraph_is_chordal``."""
    # Prepare input arguments
    c_graph = graph
    c_alpha = iterable_to_igraph_vector_int_t_view(alpha) if alpha is not None else None
    c_alpham1 = iterable_vertex_indices_to_igraph_vector_int_t(alpham1) if alpham1 is not None else None
    c_chordal = igraph_bool_t()
    c_fillin = _VectorInt.create(0)
    c_newgraph = _Graph()

    # Call wrapped function
    igraph_is_chordal(c_graph, c_alpha, c_alpham1, c_chordal, c_fillin, c_newgraph)

    # Prepare output arguments
    chordal = c_chordal.value
    fillin = igraph_vector_int_t_to_numpy_array(c_fillin)
    newgraph = _create_graph_from_boxed(c_newgraph)

    # Construct return value
    return chordal, fillin, newgraph


def avg_nearest_neighbor_degree(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL, neighbor_degree_mode: NeighborMode = NeighborMode.ALL, weights: Optional[Iterable[float]] = None) -> tuple[RealArray, RealArray]:
    """Type-annotated wrapper for ``igraph_avg_nearest_neighbor_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_neighbor_degree_mode = c_int(neighbor_degree_mode)
    c_knn = _Vector.create(0)
    c_knnk = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_avg_nearest_neighbor_degree(c_graph, c_vids.unwrap(), c_mode, c_neighbor_degree_mode, c_knn, c_knnk, c_weights)

    # Prepare output arguments
    knn = igraph_vector_t_to_numpy_array(c_knn)
    knnk = igraph_vector_t_to_numpy_array(c_knnk)

    # Construct return value
    return knn, knnk


def degree_correlation_vector(graph: Graph, weights: Optional[Iterable[float]] = None, from_mode: NeighborMode = NeighborMode.OUT, to_mode: NeighborMode = NeighborMode.IN, directed_neighbors: bool = True) -> RealArray:
    """Type-annotated wrapper for ``igraph_degree_correlation_vector``."""
    # Prepare input arguments
    c_graph = graph
    c_knnk = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_from_mode = c_int(from_mode)
    c_to_mode = c_int(to_mode)
    c_directed_neighbors = any_to_igraph_bool_t(directed_neighbors)

    # Call wrapped function
    igraph_degree_correlation_vector(c_graph, c_knnk, c_weights, c_from_mode, c_to_mode, c_directed_neighbors)

    # Prepare output arguments
    knnk = igraph_vector_t_to_numpy_array(c_knnk)

    # Construct return value
    return knnk


def strength(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = True, weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_strength``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_strength(c_graph, c_res, c_vids.unwrap(), c_mode, c_loops, c_weights)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def centralization(scores: Iterable[float], theoretical_max: float = 0, normalized: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_centralization``."""
    # Prepare input arguments
    c_scores = iterable_to_igraph_vector_t_view(scores)
    c_theoretical_max = theoretical_max
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    c__result = igraph_centralization(c_scores, c_theoretical_max, c_normalized)

    # Construct return value
    return c__result


def centralization_degree(graph: Graph, mode: NeighborMode = NeighborMode.ALL, loops: bool = True, normalized: bool = True) -> tuple[RealArray, float, float]:
    """Type-annotated wrapper for ``igraph_centralization_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)
    c_centralization = igraph_real_t()
    c_theoretical_max = igraph_real_t()
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_centralization_degree(c_graph, c_res, c_mode, c_loops, c_centralization, c_theoretical_max, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    centralization = c_centralization.value
    theoretical_max = c_theoretical_max.value

    # Construct return value
    return res, centralization, theoretical_max


def centralization_degree_tmax(loops: bool, graph: Optional[Graph] = None, nodes: int = 0, mode: NeighborMode = NeighborMode.ALL) -> float:
    """Type-annotated wrapper for ``igraph_centralization_degree_tmax``."""
    # Prepare input arguments
    c_graph = graph if graph is not None else None
    c_nodes = nodes
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_degree_tmax(c_graph, c_nodes, c_mode, c_loops, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def centralization_betweenness(graph: Graph, directed: bool = True, normalized: bool = True) -> tuple[RealArray, float, float]:
    """Type-annotated wrapper for ``igraph_centralization_betweenness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_centralization = igraph_real_t()
    c_theoretical_max = igraph_real_t()
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_centralization_betweenness(c_graph, c_res, c_directed, c_centralization, c_theoretical_max, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    centralization = c_centralization.value
    theoretical_max = c_theoretical_max.value

    # Construct return value
    return res, centralization, theoretical_max


def centralization_betweenness_tmax(graph: Optional[Graph] = None, nodes: int = 0, directed: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_centralization_betweenness_tmax``."""
    # Prepare input arguments
    c_graph = graph if graph is not None else None
    c_nodes = nodes
    c_directed = any_to_igraph_bool_t(directed)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_betweenness_tmax(c_graph, c_nodes, c_directed, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def centralization_closeness(graph: Graph, mode: NeighborMode = NeighborMode.OUT, normalized: bool = True) -> tuple[RealArray, float, float]:
    """Type-annotated wrapper for ``igraph_centralization_closeness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_mode = c_int(mode)
    c_centralization = igraph_real_t()
    c_theoretical_max = igraph_real_t()
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_centralization_closeness(c_graph, c_res, c_mode, c_centralization, c_theoretical_max, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    centralization = c_centralization.value
    theoretical_max = c_theoretical_max.value

    # Construct return value
    return res, centralization, theoretical_max


def centralization_closeness_tmax(graph: Optional[Graph] = None, nodes: int = 0, mode: NeighborMode = NeighborMode.OUT) -> float:
    """Type-annotated wrapper for ``igraph_centralization_closeness_tmax``."""
    # Prepare input arguments
    c_graph = graph if graph is not None else None
    c_nodes = nodes
    c_mode = c_int(mode)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_closeness_tmax(c_graph, c_nodes, c_mode, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_centralization_eigenvector_centrality: no Python type known for type: ARPACK_OPTIONS


def centralization_eigenvector_centrality_tmax(graph: Optional[Graph] = None, nodes: int = 0, directed: bool = False, scale: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_centralization_eigenvector_centrality_tmax``."""
    # Prepare input arguments
    c_graph = graph if graph is not None else None
    c_nodes = nodes
    c_directed = any_to_igraph_bool_t(directed)
    c_scale = any_to_igraph_bool_t(scale)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_eigenvector_centrality_tmax(c_graph, c_nodes, c_directed, c_scale, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def assortativity_nominal(graph: Graph, types: Iterable[int], directed: bool = True, normalized: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_assortativity_nominal``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_int_t_view(types)
    c_res = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_assortativity_nominal(c_graph, c_types, c_res, c_directed, c_normalized)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def assortativity(graph: Graph, values: Iterable[float], values_in: Optional[Iterable[float]] = None, directed: bool = True, normalized: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_assortativity``."""
    # Prepare input arguments
    c_graph = graph
    c_values = iterable_to_igraph_vector_t_view(values)
    c_values_in = iterable_to_igraph_vector_t_view(values_in) if values_in is not None else None
    c_res = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_assortativity(c_graph, c_values, c_values_in, c_res, c_directed, c_normalized)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def assortativity_degree(graph: Graph, directed: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_assortativity_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_assortativity_degree(c_graph, c_res, c_directed)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def joint_degree_matrix(graph: Graph, max_out_degree: int = -1, max_in_degree: int = -1, weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_joint_degree_matrix``."""
    # Prepare input arguments
    c_graph = graph
    c_jdm = _Matrix.create(0)
    c_max_out_degree = max_out_degree
    c_max_in_degree = max_in_degree
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_joint_degree_matrix(c_graph, c_jdm, c_max_out_degree, c_max_in_degree, c_weights)

    # Prepare output arguments
    jdm = igraph_matrix_t_to_numpy_array(c_jdm)

    # Construct return value
    return jdm


def contract_vertices(graph: Graph, mapping: Iterable[int], vertex_attr_comb: Optional[AttributeCombinationSpecification] = None) -> None:
    """Type-annotated wrapper for ``igraph_contract_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_mapping = iterable_to_igraph_vector_int_t_view(mapping)
    c_vertex_attr_comb = mapping_to_attribute_combination_t(vertex_attr_comb)

    # Call wrapped function
    igraph_contract_vertices(c_graph, c_mapping, c_vertex_attr_comb)


def eccentricity(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL) -> RealArray:
    """Type-annotated wrapper for ``igraph_eccentricity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_eccentricity(c_graph, c_res, c_vids.unwrap(), c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def eccentricity_dijkstra(graph: Graph, weights: Optional[Iterable[float]] = None, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL) -> RealArray:
    """Type-annotated wrapper for ``igraph_eccentricity_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_eccentricity_dijkstra(c_graph, c_weights, c_res, c_vids.unwrap(), c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def graph_center(graph: Graph, mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_graph_center``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_graph_center(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def graph_center_dijkstra(graph: Graph, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_graph_center_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_res = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_graph_center_dijkstra(c_graph, c_weights, c_res, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def radius(graph: Graph, mode: NeighborMode = NeighborMode.ALL) -> float:
    """Type-annotated wrapper for ``igraph_radius``."""
    # Prepare input arguments
    c_graph = graph
    c_radius = igraph_real_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_radius(c_graph, c_radius, c_mode)

    # Prepare output arguments
    radius = c_radius.value

    # Construct return value
    return radius


def radius_dijkstra(graph: Graph, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.ALL) -> float:
    """Type-annotated wrapper for ``igraph_radius_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_radius = igraph_real_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_radius_dijkstra(c_graph, c_weights, c_radius, c_mode)

    # Prepare output arguments
    radius = c_radius.value

    # Construct return value
    return radius


def pseudo_diameter(graph: Graph, start_vid: VertexLike, directed: bool = True, unconnected: bool = True) -> tuple[float, int, int]:
    """Type-annotated wrapper for ``igraph_pseudo_diameter``."""
    # Prepare input arguments
    c_graph = graph
    c_diameter = igraph_real_t()
    c_start_vid = vertexlike_to_igraph_integer_t(start_vid)
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_unconnected = any_to_igraph_bool_t(unconnected)

    # Call wrapped function
    igraph_pseudo_diameter(c_graph, c_diameter, c_start_vid, c_from, c_to, c_directed, c_unconnected)

    # Prepare output arguments
    diameter = c_diameter.value
    from_ = c_from.value
    to = c_to.value

    # Construct return value
    return diameter, from_, to


def pseudo_diameter_dijkstra(graph: Graph, start_vid: VertexLike, weights: Optional[Iterable[float]] = None, directed: bool = True, unconnected: bool = True) -> tuple[float, int, int]:
    """Type-annotated wrapper for ``igraph_pseudo_diameter_dijkstra``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_diameter = igraph_real_t()
    c_start_vid = vertexlike_to_igraph_integer_t(start_vid)
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_unconnected = any_to_igraph_bool_t(unconnected)

    # Call wrapped function
    igraph_pseudo_diameter_dijkstra(c_graph, c_weights, c_diameter, c_start_vid, c_from, c_to, c_directed, c_unconnected)

    # Prepare output arguments
    diameter = c_diameter.value
    from_ = c_from.value
    to = c_to.value

    # Construct return value
    return diameter, from_, to


def diversity(graph: Graph, weights: Optional[Iterable[float]] = None, vids: VertexSelector = "all") -> RealArray:
    """Type-annotated wrapper for ``igraph_diversity``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)

    # Call wrapped function
    igraph_diversity(c_graph, c_weights, c_res, c_vids.unwrap())

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def random_walk(graph: Graph, start: VertexLike, steps: int, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT, stuck: RandomWalkStuck = RandomWalkStuck.RETURN) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_random_walk``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_vertices = _VectorInt.create(0)
    c_edges = _VectorInt.create(0)
    c_start = vertexlike_to_igraph_integer_t(start)
    c_mode = c_int(mode)
    c_steps = steps
    c_stuck = c_int(stuck)

    # Call wrapped function
    igraph_random_walk(c_graph, c_weights, c_vertices, c_edges, c_start, c_mode, c_steps, c_stuck)

    # Prepare output arguments
    vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return vertices, edges


def random_edge_walk(graph: Graph, start: VertexLike, steps: int, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT, stuck: RandomWalkStuck = RandomWalkStuck.RETURN) -> IntArray:
    """Type-annotated wrapper for ``igraph_random_edge_walk``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_edgewalk = _VectorInt.create(0)
    c_start = vertexlike_to_igraph_integer_t(start)
    c_mode = c_int(mode)
    c_steps = steps
    c_stuck = c_int(stuck)

    # Call wrapped function
    igraph_random_edge_walk(c_graph, c_weights, c_edgewalk, c_start, c_mode, c_steps, c_stuck)

    # Prepare output arguments
    edgewalk = igraph_vector_int_t_to_numpy_array(c_edgewalk)

    # Construct return value
    return edgewalk


def global_efficiency(graph: Graph, weights: Optional[Iterable[float]] = None, directed: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_global_efficiency``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_global_efficiency(c_graph, c_res, c_weights, c_directed)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def local_efficiency(graph: Graph, vids: VertexSelector = "all", weights: Optional[Iterable[float]] = None, directed: bool = True, mode: NeighborMode = NeighborMode.ALL) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_efficiency``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_efficiency(c_graph, c_res, c_vids.unwrap(), c_weights, c_directed, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def average_local_efficiency(graph: Graph, weights: Optional[Iterable[float]] = None, directed: bool = True, mode: NeighborMode = NeighborMode.ALL) -> float:
    """Type-annotated wrapper for ``igraph_average_local_efficiency``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_average_local_efficiency(c_graph, c_res, c_weights, c_directed, c_mode)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def transitive_closure_dag(graph: Graph) -> Graph:
    """Type-annotated wrapper for ``igraph_transitive_closure_dag``."""
    # Prepare input arguments
    c_graph = graph
    c_closure = _Graph()

    # Call wrapped function
    igraph_transitive_closure_dag(c_graph, c_closure)

    # Prepare output arguments
    closure = _create_graph_from_boxed(c_closure)

    # Construct return value
    return closure


def trussness(graph: Graph) -> IntArray:
    """Type-annotated wrapper for ``igraph_trussness``."""
    # Prepare input arguments
    c_graph = graph
    c_trussness = _VectorInt.create(0)

    # Call wrapped function
    igraph_trussness(c_graph, c_trussness)

    # Prepare output arguments
    trussness = igraph_vector_int_t_to_numpy_array(c_trussness)

    # Construct return value
    return trussness

# igraph_is_bigraphical: no Python type known for type: EDGE_TYPE_SW

# igraph_is_graphical: no Python type known for type: EDGE_TYPE_SW

# igraph_bfs: no Python type known for type: BFS_FUNC


def bfs_simple(graph: Graph, root: VertexLike, mode: NeighborMode = NeighborMode.OUT) -> tuple[IntArray, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_bfs_simple``."""
    # Prepare input arguments
    c_graph = graph
    c_root = vertexlike_to_igraph_integer_t(root)
    c_mode = c_int(mode)
    c_order = _VectorInt.create(0)
    c_layers = _VectorInt.create(0)
    c_parents = _VectorInt.create(0)

    # Call wrapped function
    igraph_bfs_simple(c_graph, c_root, c_mode, c_order, c_layers, c_parents)

    # Prepare output arguments
    order = igraph_vector_int_t_to_numpy_array(c_order)
    layers = igraph_vector_int_t_to_numpy_array(c_layers)
    parents = igraph_vector_int_t_to_numpy_array(c_parents)

    # Construct return value
    return order, layers, parents

# igraph_dfs: no Python type known for type: DFS_FUNC


def bipartite_projection_size(graph: Graph, types: Optional[Iterable[Any]] = None) -> tuple[int, int, int, int]:
    """Type-annotated wrapper for ``igraph_bipartite_projection_size``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None
    c_vcount1 = igraph_integer_t()
    c_ecount1 = igraph_integer_t()
    c_vcount2 = igraph_integer_t()
    c_ecount2 = igraph_integer_t()

    # Call wrapped function
    igraph_bipartite_projection_size(c_graph, c_types, c_vcount1, c_ecount1, c_vcount2, c_ecount2)

    # Prepare output arguments
    vcount1 = c_vcount1.value
    ecount1 = c_ecount1.value
    vcount2 = c_vcount2.value
    ecount2 = c_ecount2.value

    # Construct return value
    return vcount1, ecount1, vcount2, ecount2


def bipartite_projection(graph: Graph, types: Optional[Iterable[Any]] = None, probe1: int = -1) -> tuple[Graph, Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_bipartite_projection``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None
    c_proj1 = _Graph()
    c_proj2 = _Graph()
    c_multiplicity1 = _VectorInt.create(0)
    c_multiplicity2 = _VectorInt.create(0)
    c_probe1 = probe1

    # Call wrapped function
    igraph_bipartite_projection(c_graph, c_types, c_proj1, c_proj2, c_multiplicity1, c_multiplicity2, c_probe1)

    # Prepare output arguments
    proj1 = _create_graph_from_boxed(c_proj1)
    proj2 = _create_graph_from_boxed(c_proj2)
    multiplicity1 = igraph_vector_int_t_to_numpy_array(c_multiplicity1)
    multiplicity2 = igraph_vector_int_t_to_numpy_array(c_multiplicity2)

    # Construct return value
    return proj1, proj2, multiplicity1, multiplicity2


def create_bipartite(types: Iterable[Any], edges: Iterable[int], directed: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_create_bipartite``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None
    c_edges = iterable_to_igraph_vector_int_t_view(edges)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_create_bipartite(c_graph, c_types, c_edges, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def biadjacency(incidence: MatrixLike, directed: bool = False, mode: NeighborMode = NeighborMode.ALL, multiple: bool = False) -> tuple[Graph, BoolArray]:
    """Type-annotated wrapper for ``igraph_biadjacency``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorBool.create(0)
    c_incidence = sequence_to_igraph_matrix_t_view(incidence)
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_biadjacency(c_graph, c_types, c_incidence, c_directed, c_mode, c_multiple)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = c_types.value

    # Construct return value
    return graph, types


def get_biadjacency(graph: Graph, types: Optional[Iterable[Any]] = None) -> tuple[RealArray, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_get_biadjacency``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None
    c_res = _Matrix.create(0)
    c_row_ids = _VectorInt.create(0)
    c_col_ids = _VectorInt.create(0)

    # Call wrapped function
    igraph_get_biadjacency(c_graph, c_types, c_res, c_row_ids, c_col_ids)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)
    row_ids = igraph_vector_int_t_to_numpy_array(c_row_ids)
    col_ids = igraph_vector_int_t_to_numpy_array(c_col_ids)

    # Construct return value
    return res, row_ids, col_ids


def is_bipartite(graph: Graph) -> tuple[bool, BoolArray]:
    """Type-annotated wrapper for ``igraph_is_bipartite``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_type = _VectorBool.create(0)

    # Call wrapped function
    igraph_is_bipartite(c_graph, c_res, c_type)

    # Prepare output arguments
    res = c_res.value
    type = c_type.value

    # Construct return value
    return res, type


def bipartite_game_gnp(n1: int, n2: int, p: float, directed: bool = False, mode: NeighborMode = NeighborMode.ALL) -> tuple[Graph, BoolArray]:
    """Type-annotated wrapper for ``igraph_bipartite_game_gnp``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorBool.create(0)
    c_n1 = n1
    c_n2 = n2
    c_p = p
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_bipartite_game_gnp(c_graph, c_types, c_n1, c_n2, c_p, c_directed, c_mode)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = c_types.value

    # Construct return value
    return graph, types


def bipartite_game_gnm(n1: int, n2: int, m: int, directed: bool = False, mode: NeighborMode = NeighborMode.ALL, multiple: bool = False) -> tuple[Graph, BoolArray]:
    """Type-annotated wrapper for ``igraph_bipartite_game_gnm``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorBool.create(0)
    c_n1 = n1
    c_n2 = n2
    c_m = m
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_bipartite_game_gnm(c_graph, c_types, c_n1, c_n2, c_m, c_directed, c_mode, c_multiple)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = c_types.value

    # Construct return value
    return graph, types


def bipartite_game(type: ErdosRenyiType, n1: int, n2: int, p: float = 0.0, m: int = 0, directed: bool = False, mode: NeighborMode = NeighborMode.ALL) -> tuple[Graph, BoolArray]:
    """Type-annotated wrapper for ``igraph_bipartite_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorBool.create(0)
    c_type = c_int(type)
    c_n1 = n1
    c_n2 = n2
    c_p = p
    c_m = m
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_bipartite_game(c_graph, c_types, c_type, c_n1, c_n2, c_p, c_m, c_directed, c_mode)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)
    types = c_types.value

    # Construct return value
    return graph, types

# igraph_get_laplacian: no Python type known for type: LAPLACIAN_NORMALIZATION

# igraph_get_laplacian_sparse: no Python type known for type: SPARSEMAT


def connected_components(graph: Graph, mode: Connectedness = Connectedness.WEAK) -> tuple[IntArray, IntArray, int]:
    """Type-annotated wrapper for ``igraph_connected_components``."""
    # Prepare input arguments
    c_graph = graph
    c_membership = _VectorInt.create(0)
    c_csize = _VectorInt.create(0)
    c_no = igraph_integer_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_connected_components(c_graph, c_membership, c_csize, c_no, c_mode)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    csize = igraph_vector_int_t_to_numpy_array(c_csize)
    no = c_no.value

    # Construct return value
    return membership, csize, no


def is_connected(graph: Graph, mode: Connectedness = Connectedness.WEAK) -> bool:
    """Type-annotated wrapper for ``igraph_is_connected``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_is_connected(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_decompose: no Python type known for type: GRAPH_LIST


def articulation_points(graph: Graph) -> IntArray:
    """Type-annotated wrapper for ``igraph_articulation_points``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_articulation_points(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def biconnected_components(graph: Graph) -> tuple[int, list[IntArray], list[IntArray], list[IntArray], IntArray]:
    """Type-annotated wrapper for ``igraph_biconnected_components``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()
    c_tree_edges = _VectorIntList.create(0)
    c_component_edges = _VectorIntList.create(0)
    c_components = _VectorIntList.create(0)
    c_articulation_points = _VectorInt.create(0)

    # Call wrapped function
    igraph_biconnected_components(c_graph, c_no, c_tree_edges, c_component_edges, c_components, c_articulation_points)

    # Prepare output arguments
    no = c_no.value
    tree_edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_tree_edges)
    component_edges = igraph_vector_int_list_t_to_list_of_numpy_array(c_component_edges)
    components = igraph_vector_int_list_t_to_list_of_numpy_array(c_components)
    articulation_points = igraph_vector_int_t_to_numpy_array(c_articulation_points)

    # Construct return value
    return no, tree_edges, component_edges, components, articulation_points


def bridges(graph: Graph) -> IntArray:
    """Type-annotated wrapper for ``igraph_bridges``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_bridges(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def cliques(graph: Graph, min_size: int = 0, max_size: int = 0) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_cliques``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_cliques(c_graph, c_res, c_min_size, c_max_size)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res

# igraph_cliques_callback: no Python type known for type: CLIQUE_FUNC


def clique_size_hist(graph: Graph, min_size: int = 0, max_size: int = 0) -> RealArray:
    """Type-annotated wrapper for ``igraph_clique_size_hist``."""
    # Prepare input arguments
    c_graph = graph
    c_hist = _Vector.create(0)
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_clique_size_hist(c_graph, c_hist, c_min_size, c_max_size)

    # Prepare output arguments
    hist = igraph_vector_t_to_numpy_array(c_hist)

    # Construct return value
    return hist


def largest_cliques(graph: Graph) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_largest_cliques``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)

    # Call wrapped function
    igraph_largest_cliques(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def maximal_cliques(graph: Graph, min_size: int = 0, max_size: int = 0) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_maximal_cliques``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_maximal_cliques(c_graph, c_res, c_min_size, c_max_size)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def maximal_cliques_subset(graph: Graph, subset: Iterable[VertexLike], outfile: Optional[FileLike] = None, min_size: int = 0, max_size: int = 0) -> tuple[list[IntArray], int]:
    """Type-annotated wrapper for ``igraph_maximal_cliques_subset``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_subset = iterable_vertex_indices_to_igraph_vector_int_t(subset)
        c_res = _VectorIntList.create(0)
        c_no = igraph_integer_t()
        c_outfile = py__stack.enter_context(any_to_file_ptr(outfile, "w"))
        c_min_size = min_size
        c_max_size = max_size

        # Call wrapped function
        igraph_maximal_cliques_subset(c_graph, c_subset, c_res, c_no, c_outfile, c_min_size, c_max_size)

        # Prepare output arguments
        res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)
        no = c_no.value

        # Construct return value
        return res, no

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011

# igraph_maximal_cliques_callback: no Python type known for type: CLIQUE_FUNC


def maximal_cliques_count(graph: Graph, min_size: int = 0, max_size: int = 0) -> int:
    """Type-annotated wrapper for ``igraph_maximal_cliques_count``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_maximal_cliques_count(c_graph, c_no, c_min_size, c_max_size)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no


def maximal_cliques_file(graph: Graph, res: FileLike, min_size: int = 0, max_size: int = 0) -> None:
    """Type-annotated wrapper for ``igraph_maximal_cliques_file``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_res = py__stack.enter_context(any_to_file_ptr(res, "w"))
        c_min_size = min_size
        c_max_size = max_size

        # Call wrapped function
        igraph_maximal_cliques_file(c_graph, c_res, c_min_size, c_max_size)


def maximal_cliques_hist(graph: Graph, min_size: int = 0, max_size: int = 0) -> RealArray:
    """Type-annotated wrapper for ``igraph_maximal_cliques_hist``."""
    # Prepare input arguments
    c_graph = graph
    c_hist = _Vector.create(0)
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_maximal_cliques_hist(c_graph, c_hist, c_min_size, c_max_size)

    # Prepare output arguments
    hist = igraph_vector_t_to_numpy_array(c_hist)

    # Construct return value
    return hist


def clique_number(graph: Graph) -> int:
    """Type-annotated wrapper for ``igraph_clique_number``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()

    # Call wrapped function
    igraph_clique_number(c_graph, c_no)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no


def weighted_cliques(graph: Graph, vertex_weights: Optional[Iterable[float]] = None, min_weight: float = 0, max_weight: float = 0, maximal: bool = False) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_weighted_cliques``."""
    # Prepare input arguments
    c_graph = graph
    c_vertex_weights = vertex_weights_to_igraph_vector_t_view(vertex_weights, graph)
    c_res = _VectorIntList.create(0)
    c_min_weight = min_weight
    c_max_weight = max_weight
    c_maximal = any_to_igraph_bool_t(maximal)

    # Call wrapped function
    igraph_weighted_cliques(c_graph, c_vertex_weights, c_res, c_min_weight, c_max_weight, c_maximal)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def largest_weighted_cliques(graph: Graph, vertex_weights: Optional[Iterable[float]] = None) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_largest_weighted_cliques``."""
    # Prepare input arguments
    c_graph = graph
    c_vertex_weights = vertex_weights_to_igraph_vector_t_view(vertex_weights, graph)
    c_res = _VectorIntList.create(0)

    # Call wrapped function
    igraph_largest_weighted_cliques(c_graph, c_vertex_weights, c_res)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def weighted_clique_number(graph: Graph, vertex_weights: Optional[Iterable[float]] = None) -> float:
    """Type-annotated wrapper for ``igraph_weighted_clique_number``."""
    # Prepare input arguments
    c_graph = graph
    c_vertex_weights = vertex_weights_to_igraph_vector_t_view(vertex_weights, graph)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_weighted_clique_number(c_graph, c_vertex_weights, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def independent_vertex_sets(graph: Graph, min_size: int = 0, max_size: int = 0) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_independent_vertex_sets``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_independent_vertex_sets(c_graph, c_res, c_min_size, c_max_size)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def largest_independent_vertex_sets(graph: Graph) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_largest_independent_vertex_sets``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)

    # Call wrapped function
    igraph_largest_independent_vertex_sets(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def maximal_independent_vertex_sets(graph: Graph) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_maximal_independent_vertex_sets``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorIntList.create(0)

    # Call wrapped function
    igraph_maximal_independent_vertex_sets(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_list_t_to_list_of_numpy_array(c_res)

    # Construct return value
    return res


def independence_number(graph: Graph) -> int:
    """Type-annotated wrapper for ``igraph_independence_number``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()

    # Call wrapped function
    igraph_independence_number(c_graph, c_no)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no


def layout_random(graph: Graph) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_random``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)

    # Call wrapped function
    igraph_layout_random(c_graph, c_res)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_circle(graph: Graph, order: VertexSelector = "all") -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_circle``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_order = vertex_selector_to_igraph_vs_t(order, graph)

    # Call wrapped function
    igraph_layout_circle(c_graph, c_res, c_order.unwrap())

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_grid(graph: Graph, width: int = 0) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_grid``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_width = width

    # Call wrapped function
    igraph_layout_grid(c_graph, c_res, c_width)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_grid_3d(graph: Graph, width: int = 0, height: int = 0) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_grid_3d``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_width = width
    c_height = height

    # Call wrapped function
    igraph_layout_grid_3d(c_graph, c_res, c_width, c_height)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_layout_fruchterman_reingold: No such type: 'DEPRECATED'


def layout_reingold_tilford(graph: Graph, mode: NeighborMode = NeighborMode.OUT, roots: Optional[Iterable[VertexLike]] = None, rootlevel: Optional[Iterable[int]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_reingold_tilford``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_mode = c_int(mode)
    c_roots = iterable_vertex_indices_to_igraph_vector_int_t(roots) if roots is not None else None
    c_rootlevel = iterable_to_igraph_vector_int_t_view(rootlevel) if rootlevel is not None else None

    # Call wrapped function
    igraph_layout_reingold_tilford(c_graph, c_res, c_mode, c_roots, c_rootlevel)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_reingold_tilford_circular(graph: Graph, mode: NeighborMode = NeighborMode.OUT, roots: Optional[Iterable[VertexLike]] = None, rootlevel: Optional[Iterable[int]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_reingold_tilford_circular``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_mode = c_int(mode)
    c_roots = iterable_vertex_indices_to_igraph_vector_int_t(roots) if roots is not None else None
    c_rootlevel = iterable_to_igraph_vector_int_t_view(rootlevel) if rootlevel is not None else None

    # Call wrapped function
    igraph_layout_reingold_tilford_circular(c_graph, c_res, c_mode, c_roots, c_rootlevel)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def roots_for_tree_layout(graph: Graph, heuristic: RootChoice, mode: NeighborMode = NeighborMode.OUT) -> IntArray:
    """Type-annotated wrapper for ``igraph_roots_for_tree_layout``."""
    # Prepare input arguments
    c_graph = graph
    c_mode = c_int(mode)
    c_roots = _VectorInt.create(0)
    c_heuristic = c_int(heuristic)

    # Call wrapped function
    igraph_roots_for_tree_layout(c_graph, c_mode, c_roots, c_heuristic)

    # Prepare output arguments
    roots = igraph_vector_int_t_to_numpy_array(c_roots)

    # Construct return value
    return roots


def layout_random_3d(graph: Graph) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_random_3d``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)

    # Call wrapped function
    igraph_layout_random_3d(c_graph, c_res)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_sphere(graph: Graph) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_sphere``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)

    # Call wrapped function
    igraph_layout_sphere(c_graph, c_res)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_layout_fruchterman_reingold_3d: No such type: 'DEPRECATED'


def layout_graphopt(graph: Graph, res: MatrixLike, niter: int = 500, node_charge: float = 0.001, node_mass: float = 30, spring_length: float = 0, spring_constant: float = 1, max_sa_movement: float = 5, use_seed: bool = False) -> None:
    """Type-annotated wrapper for ``igraph_layout_graphopt``."""
    # Prepare input arguments
    c_graph = graph
    c_res = sequence_to_igraph_matrix_t(res)
    c_niter = niter
    c_node_charge = node_charge
    c_node_mass = node_mass
    c_spring_length = spring_length
    c_spring_constant = spring_constant
    c_max_sa_movement = max_sa_movement
    c_use_seed = any_to_igraph_bool_t(use_seed)

    # Call wrapped function
    igraph_layout_graphopt(c_graph, c_res, c_niter, c_node_charge, c_node_mass, c_spring_length, c_spring_constant, c_max_sa_movement, c_use_seed)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

# igraph_layout_drl: no Python type known for type: DRL_OPTIONS

# igraph_layout_drl_3d: no Python type known for type: DRL_OPTIONS

# igraph_layout_merge_dla: no Python type known for type: GRAPH_PTR_LIST


def layout_sugiyama(graph: Graph, layers: Optional[Iterable[int]] = None, hgap: float = 1, vgap: float = 1, maxiter: int = 100, weights: Optional[Iterable[float]] = None) -> tuple[RealArray, Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_layout_sugiyama``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_extd_graph = _Graph()
    c_extd_to_orig_eids = _VectorInt.create(0)
    c_layers = iterable_to_igraph_vector_int_t_view(layers) if layers is not None else None
    c_hgap = hgap
    c_vgap = vgap
    c_maxiter = maxiter
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_layout_sugiyama(c_graph, c_res, c_extd_graph, c_extd_to_orig_eids, c_layers, c_hgap, c_vgap, c_maxiter, c_weights)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)
    extd_graph = _create_graph_from_boxed(c_extd_graph)
    extd_to_orig_eids = igraph_vector_int_t_to_numpy_array(c_extd_to_orig_eids)

    # Construct return value
    return res, extd_graph, extd_to_orig_eids


def layout_mds(graph: Graph, dist: Optional[MatrixLike] = None, dim: int = 2) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_mds``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_dist = sequence_to_igraph_matrix_t_view(dist) if dist is not None else None
    c_dim = dim

    # Call wrapped function
    igraph_layout_mds(c_graph, c_res, c_dist, c_dim)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_bipartite(graph: Graph, types: Optional[Iterable[Any]] = None, hgap: float = 1, vgap: float = 1, maxiter: int = 100) -> RealArray:
    """Type-annotated wrapper for ``igraph_layout_bipartite``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None
    c_res = _Matrix.create(0)
    c_hgap = hgap
    c_vgap = vgap
    c_maxiter = maxiter

    # Call wrapped function
    igraph_layout_bipartite(c_graph, c_types, c_res, c_hgap, c_vgap, c_maxiter)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def layout_umap(graph: Graph, res: MatrixLike, use_seed: bool = False, distances: Optional[Iterable[float]] = None, min_dist: float = 0.0, epochs: int = 200, distances_are_weights: bool = False) -> None:
    """Type-annotated wrapper for ``igraph_layout_umap``."""
    # Prepare input arguments
    c_graph = graph
    c_res = sequence_to_igraph_matrix_t(res)
    c_use_seed = any_to_igraph_bool_t(use_seed)
    c_distances = iterable_to_igraph_vector_t_view(distances) if distances is not None else None
    c_min_dist = min_dist
    c_epochs = epochs
    c_distances_are_weights = any_to_igraph_bool_t(distances_are_weights)

    # Call wrapped function
    igraph_layout_umap(c_graph, c_res, c_use_seed, c_distances, c_min_dist, c_epochs, c_distances_are_weights)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)


def layout_umap_3d(graph: Graph, res: MatrixLike, use_seed: bool = False, distances: Optional[Iterable[float]] = None, min_dist: float = 0.0, epochs: int = 200, distances_are_weights: bool = False) -> None:
    """Type-annotated wrapper for ``igraph_layout_umap_3d``."""
    # Prepare input arguments
    c_graph = graph
    c_res = sequence_to_igraph_matrix_t(res)
    c_use_seed = any_to_igraph_bool_t(use_seed)
    c_distances = iterable_to_igraph_vector_t_view(distances) if distances is not None else None
    c_min_dist = min_dist
    c_epochs = epochs
    c_distances_are_weights = any_to_igraph_bool_t(distances_are_weights)

    # Call wrapped function
    igraph_layout_umap_3d(c_graph, c_res, c_use_seed, c_distances, c_min_dist, c_epochs, c_distances_are_weights)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)


def layout_umap_compute_weights(graph: Graph, distances: Iterable[float], weights: Iterable[float]) -> None:
    """Type-annotated wrapper for ``igraph_layout_umap_compute_weights``."""
    # Prepare input arguments
    c_graph = graph
    c_distances = iterable_to_igraph_vector_t_view(distances)
    c_weights = iterable_to_igraph_vector_t(weights)

    # Call wrapped function
    igraph_layout_umap_compute_weights(c_graph, c_distances, c_weights)

    # Prepare output arguments
    weights = igraph_vector_t_to_numpy_array(c_weights)


def cocitation(graph: Graph, vids: VertexSelector = "all") -> RealArray:
    """Type-annotated wrapper for ``igraph_cocitation``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)

    # Call wrapped function
    igraph_cocitation(c_graph, c_res, c_vids.unwrap())

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def bibcoupling(graph: Graph, vids: VertexSelector = "all") -> RealArray:
    """Type-annotated wrapper for ``igraph_bibcoupling``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)

    # Call wrapped function
    igraph_bibcoupling(c_graph, c_res, c_vids.unwrap())

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_dice(graph: Graph, vit_from: VertexSelector = "all", vit_to: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_dice``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_vit_from = vertex_selector_to_igraph_vs_t(vit_from, graph)
    c_vit_to = vertex_selector_to_igraph_vs_t(vit_to, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_dice(c_graph, c_res, c_vit_from.unwrap(), c_vit_to.unwrap(), c_mode, c_loops)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_dice_es(graph: Graph, es: EdgeSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_dice_es``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_es = edge_selector_to_igraph_es_t(es, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_dice_es(c_graph, c_res, c_es.unwrap(), c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_dice_pairs(graph: Graph, pairs: Iterable[VertexPair], mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_dice_pairs``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_dice_pairs(c_graph, c_res, c_pairs, c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_inverse_log_weighted(graph: Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_inverse_log_weighted``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_similarity_inverse_log_weighted(c_graph, c_res, c_vids.unwrap(), c_mode)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_jaccard(graph: Graph, vit_from: VertexSelector = "all", vit_to: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_jaccard``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_vit_from = vertex_selector_to_igraph_vs_t(vit_from, graph)
    c_vit_to = vertex_selector_to_igraph_vs_t(vit_to, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_jaccard(c_graph, c_res, c_vit_from.unwrap(), c_vit_to.unwrap(), c_mode, c_loops)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_jaccard_es(graph: Graph, es: EdgeSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_jaccard_es``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_es = edge_selector_to_igraph_es_t(es, graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_jaccard_es(c_graph, c_res, c_es.unwrap(), c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_jaccard_pairs(graph: Graph, pairs: Iterable[VertexPair], mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> RealArray:
    """Type-annotated wrapper for ``igraph_similarity_jaccard_pairs``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_jaccard_pairs(c_graph, c_res, c_pairs, c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def compare_communities(comm1: Iterable[int], comm2: Iterable[int], method: CommunityComparison = CommunityComparison.VI) -> float:
    """Type-annotated wrapper for ``igraph_compare_communities``."""
    # Prepare input arguments
    c_comm1 = iterable_to_igraph_vector_int_t_view(comm1)
    c_comm2 = iterable_to_igraph_vector_int_t_view(comm2)
    c_res = igraph_real_t()
    c_method = c_int(method)

    # Call wrapped function
    igraph_compare_communities(c_comm1, c_comm2, c_res, c_method)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def community_spinglass(graph: Graph, weights: Optional[Iterable[float]] = None, spins: int = 25, parupdate: bool = False, starttemp: float = 1, stoptemp: float = 0.01, coolfact: float = 0.99, update_rule: SpinglassUpdateMode = SpinglassUpdateMode.CONFIG, gamma: float = 1.0, implementation: SpinglassImplementation = SpinglassImplementation.ORIG, lambda_: float = 1.0) -> tuple[float, float, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_community_spinglass``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_modularity = igraph_real_t()
    c_temperature = igraph_real_t()
    c_membership = _VectorInt.create(0)
    c_csize = _VectorInt.create(0)
    c_spins = spins
    c_parupdate = any_to_igraph_bool_t(parupdate)
    c_starttemp = starttemp
    c_stoptemp = stoptemp
    c_coolfact = coolfact
    c_update_rule = c_int(update_rule)
    c_gamma = gamma
    c_implementation = c_int(implementation)
    c_lambda = lambda_

    # Call wrapped function
    igraph_community_spinglass(c_graph, c_weights, c_modularity, c_temperature, c_membership, c_csize, c_spins, c_parupdate, c_starttemp, c_stoptemp, c_coolfact, c_update_rule, c_gamma, c_implementation, c_lambda)

    # Prepare output arguments
    modularity = c_modularity.value
    temperature = c_temperature.value
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    csize = igraph_vector_int_t_to_numpy_array(c_csize)

    # Construct return value
    return modularity, temperature, membership, csize


def community_spinglass_single(graph: Graph, vertex: int, weights: Optional[Iterable[float]] = None, spins: int = 25, update_rule: SpinglassUpdateMode = SpinglassUpdateMode.CONFIG, gamma: float = 1.0) -> tuple[IntArray, float, float, int, int]:
    """Type-annotated wrapper for ``igraph_community_spinglass_single``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_vertex = vertex
    c_community = _VectorInt.create(0)
    c_cohesion = igraph_real_t()
    c_adhesion = igraph_real_t()
    c_inner_links = igraph_integer_t()
    c_outer_links = igraph_integer_t()
    c_spins = spins
    c_update_rule = c_int(update_rule)
    c_gamma = gamma

    # Call wrapped function
    igraph_community_spinglass_single(c_graph, c_weights, c_vertex, c_community, c_cohesion, c_adhesion, c_inner_links, c_outer_links, c_spins, c_update_rule, c_gamma)

    # Prepare output arguments
    community = igraph_vector_int_t_to_numpy_array(c_community)
    cohesion = c_cohesion.value
    adhesion = c_adhesion.value
    inner_links = c_inner_links.value
    outer_links = c_outer_links.value

    # Construct return value
    return community, cohesion, adhesion, inner_links, outer_links


def community_walktrap(graph: Graph, weights: Optional[Iterable[float]] = None, steps: int = 4) -> tuple[IntArray, RealArray, IntArray]:
    """Type-annotated wrapper for ``igraph_community_walktrap``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_steps = steps
    c_merges = _MatrixInt.create(0)
    c_modularity = _Vector.create(0)
    c_membership = _VectorInt.create(0)

    # Call wrapped function
    igraph_community_walktrap(c_graph, c_weights, c_steps, c_merges, c_modularity, c_membership)

    # Prepare output arguments
    merges = igraph_matrix_int_t_to_numpy_array(c_merges)
    modularity = igraph_vector_t_to_numpy_array(c_modularity)
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return merges, modularity, membership


def community_edge_betweenness(graph: Graph, directed: bool = True, weights: Optional[Iterable[float]] = None) -> tuple[IntArray, RealArray, IntArray, IntArray, RealArray, IntArray]:
    """Type-annotated wrapper for ``igraph_community_edge_betweenness``."""
    # Prepare input arguments
    c_graph = graph
    c_result = _VectorInt.create(0)
    c_edge_betweenness = _Vector.create(0)
    c_merges = _MatrixInt.create(0)
    c_bridges = _VectorInt.create(0)
    c_modularity = _Vector.create(0)
    c_membership = _VectorInt.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None

    # Call wrapped function
    igraph_community_edge_betweenness(c_graph, c_result, c_edge_betweenness, c_merges, c_bridges, c_modularity, c_membership, c_directed, c_weights)

    # Prepare output arguments
    result = igraph_vector_int_t_to_numpy_array(c_result)
    edge_betweenness = igraph_vector_t_to_numpy_array(c_edge_betweenness)
    merges = igraph_matrix_int_t_to_numpy_array(c_merges)
    bridges = igraph_vector_int_t_to_numpy_array(c_bridges)
    modularity = igraph_vector_t_to_numpy_array(c_modularity)
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return result, edge_betweenness, merges, bridges, modularity, membership


def community_eb_get_merges(graph: Graph, directed: bool, edges: Iterable[EdgeLike], weights: Optional[Iterable[float]] = None) -> tuple[IntArray, IntArray, RealArray, IntArray]:
    """Type-annotated wrapper for ``igraph_community_eb_get_merges``."""
    # Prepare input arguments
    c_graph = graph
    c_directed = any_to_igraph_bool_t(directed)
    c_edges = iterable_edge_indices_to_igraph_vector_int_t(edges)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_merges = _MatrixInt.create(0)
    c_bridges = _VectorInt.create(0)
    c_modularity = _Vector.create(0)
    c_membership = _VectorInt.create(0)

    # Call wrapped function
    igraph_community_eb_get_merges(c_graph, c_directed, c_edges, c_weights, c_merges, c_bridges, c_modularity, c_membership)

    # Prepare output arguments
    merges = igraph_matrix_int_t_to_numpy_array(c_merges)
    bridges = igraph_vector_int_t_to_numpy_array(c_bridges)
    modularity = igraph_vector_t_to_numpy_array(c_modularity)
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return merges, bridges, modularity, membership


def community_fastgreedy(graph: Graph, weights: Optional[Iterable[float]] = None) -> tuple[IntArray, RealArray, IntArray]:
    """Type-annotated wrapper for ``igraph_community_fastgreedy``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_merges = _MatrixInt.create(0)
    c_modularity = _Vector.create(0)
    c_membership = _VectorInt.create(0)

    # Call wrapped function
    igraph_community_fastgreedy(c_graph, c_weights, c_merges, c_modularity, c_membership)

    # Prepare output arguments
    merges = igraph_matrix_int_t_to_numpy_array(c_merges)
    modularity = igraph_vector_t_to_numpy_array(c_modularity)
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return merges, modularity, membership


def community_to_membership(merges: MatrixIntLike, nodes: int, steps: int) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_community_to_membership``."""
    # Prepare input arguments
    c_merges = sequence_to_igraph_matrix_int_t_view(merges)
    c_nodes = nodes
    c_steps = steps
    c_membership = _VectorInt.create(0)
    c_csize = _VectorInt.create(0)

    # Call wrapped function
    igraph_community_to_membership(c_merges, c_nodes, c_steps, c_membership, c_csize)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    csize = igraph_vector_int_t_to_numpy_array(c_csize)

    # Construct return value
    return membership, csize


def le_community_to_membership(merges: MatrixIntLike, steps: int, membership: Iterable[int]) -> IntArray:
    """Type-annotated wrapper for ``igraph_le_community_to_membership``."""
    # Prepare input arguments
    c_merges = sequence_to_igraph_matrix_int_t_view(merges)
    c_steps = steps
    c_membership = iterable_to_igraph_vector_int_t(membership)
    c_csize = _VectorInt.create(0)

    # Call wrapped function
    igraph_le_community_to_membership(c_merges, c_steps, c_membership, c_csize)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    csize = igraph_vector_int_t_to_numpy_array(c_csize)

    # Construct return value
    return csize


def modularity(graph: Graph, membership: Iterable[int], weights: Optional[Iterable[float]] = None, resolution: float = 1.0, directed: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_modularity``."""
    # Prepare input arguments
    c_graph = graph
    c_membership = iterable_to_igraph_vector_int_t_view(membership)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_resolution = resolution
    c_directed = any_to_igraph_bool_t(directed)
    c_modularity = igraph_real_t()

    # Call wrapped function
    igraph_modularity(c_graph, c_membership, c_weights, c_resolution, c_directed, c_modularity)

    # Prepare output arguments
    modularity = c_modularity.value

    # Construct return value
    return modularity


def modularity_matrix(graph: Graph, weights: Optional[Iterable[float]] = None, resolution: float = 1.0, directed: bool = True) -> RealArray:
    """Type-annotated wrapper for ``igraph_modularity_matrix``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_resolution = resolution
    c_modmat = _Matrix.create(0)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_modularity_matrix(c_graph, c_weights, c_resolution, c_modmat, c_directed)

    # Prepare output arguments
    modmat = igraph_matrix_t_to_numpy_array(c_modmat)

    # Construct return value
    return modmat


def reindex_membership(membership: Iterable[int]) -> tuple[IntArray, int]:
    """Type-annotated wrapper for ``igraph_reindex_membership``."""
    # Prepare input arguments
    c_membership = iterable_to_igraph_vector_int_t(membership)
    c_new_to_old = _VectorInt.create(0)
    c_nb_clusters = igraph_integer_t()

    # Call wrapped function
    igraph_reindex_membership(c_membership, c_new_to_old, c_nb_clusters)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    new_to_old = igraph_vector_int_t_to_numpy_array(c_new_to_old)
    nb_clusters = c_nb_clusters.value

    # Construct return value
    return new_to_old, nb_clusters

# igraph_community_leading_eigenvector: no Python type known for type: ARPACK_OPTIONS


def community_fluid_communities(graph: Graph, no_of_communities: int) -> IntArray:
    """Type-annotated wrapper for ``igraph_community_fluid_communities``."""
    # Prepare input arguments
    c_graph = graph
    c_no_of_communities = no_of_communities
    c_membership = _VectorInt.create(0)

    # Call wrapped function
    igraph_community_fluid_communities(c_graph, c_no_of_communities, c_membership)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return membership


def community_label_propagation(graph: Graph, mode: NeighborMode = NeighborMode.ALL, weights: Optional[Iterable[float]] = None, initial: Optional[Iterable[int]] = None, fixed: Optional[Iterable[bool]] = None) -> IntArray:
    """Type-annotated wrapper for ``igraph_community_label_propagation``."""
    # Prepare input arguments
    c_graph = graph
    c_membership = _VectorInt.create(0)
    c_mode = c_int(mode)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_initial = iterable_to_igraph_vector_int_t_view(initial) if initial is not None else None
    c_fixed = iterable_to_igraph_vector_bool_t_view(fixed) if fixed is not None else None

    # Call wrapped function
    igraph_community_label_propagation(c_graph, c_membership, c_mode, c_weights, c_initial, c_fixed)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return membership


def community_multilevel(graph: Graph, weights: Optional[Iterable[float]] = None, resolution: float = 1.0) -> tuple[IntArray, IntArray, RealArray]:
    """Type-annotated wrapper for ``igraph_community_multilevel``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_resolution = resolution
    c_membership = _VectorInt.create(0)
    c_memberships = _MatrixInt.create(0)
    c_modularity = _Vector.create(0)

    # Call wrapped function
    igraph_community_multilevel(c_graph, c_weights, c_resolution, c_membership, c_memberships, c_modularity)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    memberships = igraph_matrix_int_t_to_numpy_array(c_memberships)
    modularity = igraph_vector_t_to_numpy_array(c_modularity)

    # Construct return value
    return membership, memberships, modularity


def community_optimal_modularity(graph: Graph, weights: Optional[Iterable[float]] = None) -> tuple[float, IntArray]:
    """Type-annotated wrapper for ``igraph_community_optimal_modularity``."""
    # Prepare input arguments
    c_graph = graph
    c_modularity = igraph_real_t()
    c_membership = _VectorInt.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None

    # Call wrapped function
    igraph_community_optimal_modularity(c_graph, c_modularity, c_membership, c_weights)

    # Prepare output arguments
    modularity = c_modularity.value
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return modularity, membership


def community_leiden(graph: Graph, resolution: float, start: bool, weights: Optional[Iterable[float]] = None, vertex_weights: Optional[Iterable[float]] = None, beta: float = 0.01, n_iterations: int = 2, membership: Optional[Iterable[int]] = None) -> tuple[int, float]:
    """Type-annotated wrapper for ``igraph_community_leiden``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_vertex_weights = vertex_weights_to_igraph_vector_t_view(vertex_weights, graph) if vertex_weights is not None else None
    c_resolution = resolution
    c_beta = beta
    c_start = any_to_igraph_bool_t(start)
    c_n_iterations = n_iterations
    c_membership = iterable_to_igraph_vector_int_t(membership) if membership is not None else None
    c_nb_clusters = igraph_integer_t()
    c_quality = igraph_real_t()

    # Call wrapped function
    igraph_community_leiden(c_graph, c_weights, c_vertex_weights, c_resolution, c_beta, c_start, c_n_iterations, c_membership, c_nb_clusters, c_quality)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    nb_clusters = c_nb_clusters.value
    quality = c_quality.value

    # Construct return value
    return nb_clusters, quality


def split_join_distance(comm1: Iterable[int], comm2: Iterable[int]) -> tuple[int, int]:
    """Type-annotated wrapper for ``igraph_split_join_distance``."""
    # Prepare input arguments
    c_comm1 = iterable_to_igraph_vector_int_t_view(comm1)
    c_comm2 = iterable_to_igraph_vector_int_t_view(comm2)
    c_distance12 = igraph_integer_t()
    c_distance21 = igraph_integer_t()

    # Call wrapped function
    igraph_split_join_distance(c_comm1, c_comm2, c_distance12, c_distance21)

    # Prepare output arguments
    distance12 = c_distance12.value
    distance21 = c_distance21.value

    # Construct return value
    return distance12, distance21


def community_infomap(graph: Graph, e_weights: Optional[Iterable[float]] = None, v_weights: Optional[Iterable[float]] = None, nb_trials: int = 10) -> tuple[IntArray, float]:
    """Type-annotated wrapper for ``igraph_community_infomap``."""
    # Prepare input arguments
    c_graph = graph
    c_e_weights = edge_weights_to_igraph_vector_t_view(e_weights, graph)
    c_v_weights = vertex_weights_to_igraph_vector_t_view(v_weights, graph)
    c_nb_trials = nb_trials
    c_membership = _VectorInt.create(0)
    c_codelength = igraph_real_t()

    # Call wrapped function
    igraph_community_infomap(c_graph, c_e_weights, c_v_weights, c_nb_trials, c_membership, c_codelength)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    codelength = c_codelength.value

    # Construct return value
    return membership, codelength


def community_voronoi(graph: Graph, lengths: Optional[Iterable[float]] = None, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT, radius: float = -1) -> tuple[IntArray, IntArray, float]:
    """Type-annotated wrapper for ``igraph_community_voronoi``."""
    # Prepare input arguments
    c_graph = graph
    c_membership = _VectorInt.create(0)
    c_generators = _VectorInt.create(0)
    c_modularity = igraph_real_t()
    c_lengths = edge_lengths_to_igraph_vector_t_view(lengths, graph) if lengths is not None else None
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph) if weights is not None else None
    c_mode = c_int(mode)
    c_radius = radius

    # Call wrapped function
    igraph_community_voronoi(c_graph, c_membership, c_generators, c_modularity, c_lengths, c_weights, c_mode, c_radius)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    generators = igraph_vector_int_t_to_numpy_array(c_generators)
    modularity = c_modularity.value

    # Construct return value
    return membership, generators, modularity


def graphlets(graph: Graph, weights: Optional[Iterable[float]] = None, niter: int = 1000) -> tuple[list[IntArray], RealArray]:
    """Type-annotated wrapper for ``igraph_graphlets``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_cliques = _VectorIntList.create(0)
    c_Mu = _Vector.create(0)
    c_niter = niter

    # Call wrapped function
    igraph_graphlets(c_graph, c_weights, c_cliques, c_Mu, c_niter)

    # Prepare output arguments
    cliques = igraph_vector_int_list_t_to_list_of_numpy_array(c_cliques)
    Mu = igraph_vector_t_to_numpy_array(c_Mu)

    # Construct return value
    return cliques, Mu


def graphlets_candidate_basis(graph: Graph, weights: Optional[Iterable[float]] = None) -> tuple[list[IntArray], RealArray]:
    """Type-annotated wrapper for ``igraph_graphlets_candidate_basis``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_cliques = _VectorIntList.create(0)
    c_thresholds = _Vector.create(0)

    # Call wrapped function
    igraph_graphlets_candidate_basis(c_graph, c_weights, c_cliques, c_thresholds)

    # Prepare output arguments
    cliques = igraph_vector_int_list_t_to_list_of_numpy_array(c_cliques)
    thresholds = igraph_vector_t_to_numpy_array(c_thresholds)

    # Construct return value
    return cliques, thresholds


def graphlets_project(graph: Graph, cliques: Iterable[Iterable[VertexLike]], Muc: Iterable[float], weights: Optional[Iterable[float]] = None, startMu: bool = False, niter: int = 1000) -> None:
    """Type-annotated wrapper for ``igraph_graphlets_project``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_cliques = iterable_of_vertex_index_iterable_to_igraph_vector_int_list_t(cliques)
    c_Muc = iterable_to_igraph_vector_t(Muc)
    c_startMu = any_to_igraph_bool_t(startMu)
    c_niter = niter

    # Call wrapped function
    igraph_graphlets_project(c_graph, c_weights, c_cliques, c_Muc, c_startMu, c_niter)

    # Prepare output arguments
    Muc = igraph_vector_t_to_numpy_array(c_Muc)

# igraph_hrg_fit: no Python type known for type: HRG

# igraph_hrg_sample: no Python type known for type: HRG

# igraph_hrg_sample_many: no Python type known for type: HRG

# igraph_hrg_game: no Python type known for type: HRG

# igraph_hrg_consensus: no Python type known for type: HRG

# igraph_hrg_predict: no Python type known for type: HRG

# igraph_hrg_create: no Python type known for type: HRG

# igraph_hrg_resize: no Python type known for type: HRG

# igraph_hrg_size: no Python type known for type: HRG

# igraph_from_hrg_dendrogram: no Python type known for type: HRG

# igraph_get_adjacency: no Python type known for type: GETADJACENCY

# igraph_get_adjacency_sparse: no Python type known for type: SPARSEMAT


def get_edgelist(graph: Graph, bycol: bool = False) -> IntArray:
    """Type-annotated wrapper for ``igraph_get_edgelist``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_bycol = any_to_igraph_bool_t(bycol)

    # Call wrapped function
    igraph_get_edgelist(c_graph, c_res, c_bycol)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def get_stochastic(graph: Graph, column_wise: bool = False, weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_get_stochastic``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Matrix.create(0)
    c_column_wise = any_to_igraph_bool_t(column_wise)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_get_stochastic(c_graph, c_res, c_column_wise, c_weights)

    # Prepare output arguments
    res = igraph_matrix_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_get_stochastic_sparse: no Python type known for type: SPARSEMAT


def to_directed(graph: Graph, mode: ToDirected = ToDirected.MUTUAL) -> None:
    """Type-annotated wrapper for ``igraph_to_directed``."""
    # Prepare input arguments
    c_graph = graph
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_to_directed(c_graph, c_mode)


def to_undirected(graph: Graph, mode: ToUndirected = ToUndirected.COLLAPSE, edge_attr_comb: Optional[AttributeCombinationSpecification] = None) -> None:
    """Type-annotated wrapper for ``igraph_to_undirected``."""
    # Prepare input arguments
    c_graph = graph
    c_mode = c_int(mode)
    c_edge_attr_comb = mapping_to_attribute_combination_t(edge_attr_comb)

    # Call wrapped function
    igraph_to_undirected(c_graph, c_mode, c_edge_attr_comb)


def read_graph_edgelist(instream: FileLike, n: int = 0, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_read_graph_edgelist``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = _Graph()
        c_instream = py__stack.enter_context(any_to_file_ptr(instream, "r"))
        c_n = n
        c_directed = any_to_igraph_bool_t(directed)

        # Call wrapped function
        igraph_read_graph_edgelist(c_graph, c_instream, c_n, c_directed)

        # Prepare output arguments
        graph = _create_graph_from_boxed(c_graph)

        # Construct return value
        return graph

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011

# igraph_read_graph_ncol: no Python type known for type: VECTOR_STR

# igraph_read_graph_lgl: no Python type known for type: ADD_WEIGHTS


def read_graph_pajek(instream: FileLike) -> Graph:
    """Type-annotated wrapper for ``igraph_read_graph_pajek``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = _Graph()
        c_instream = py__stack.enter_context(any_to_file_ptr(instream, "r"))

        # Call wrapped function
        igraph_read_graph_pajek(c_graph, c_instream)

        # Prepare output arguments
        graph = _create_graph_from_boxed(c_graph)

        # Construct return value
        return graph

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011


def read_graph_graphml(instream: FileLike, index: int = 0) -> Graph:
    """Type-annotated wrapper for ``igraph_read_graph_graphml``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = _Graph()
        c_instream = py__stack.enter_context(any_to_file_ptr(instream, "r"))
        c_index = index

        # Call wrapped function
        igraph_read_graph_graphml(c_graph, c_instream, c_index)

        # Prepare output arguments
        graph = _create_graph_from_boxed(c_graph)

        # Construct return value
        return graph

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011

# igraph_read_graph_dimacs_flow: no Python type known for type: VECTOR_STR


def read_graph_graphdb(instream: FileLike, directed: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_read_graph_graphdb``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = _Graph()
        c_instream = py__stack.enter_context(any_to_file_ptr(instream, "r"))
        c_directed = any_to_igraph_bool_t(directed)

        # Call wrapped function
        igraph_read_graph_graphdb(c_graph, c_instream, c_directed)

        # Prepare output arguments
        graph = _create_graph_from_boxed(c_graph)

        # Construct return value
        return graph

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011


def read_graph_gml(instream: FileLike) -> Graph:
    """Type-annotated wrapper for ``igraph_read_graph_gml``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = _Graph()
        c_instream = py__stack.enter_context(any_to_file_ptr(instream, "r"))

        # Call wrapped function
        igraph_read_graph_gml(c_graph, c_instream)

        # Prepare output arguments
        graph = _create_graph_from_boxed(c_graph)

        # Construct return value
        return graph

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011


def read_graph_dl(instream: FileLike, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_read_graph_dl``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = _Graph()
        c_instream = py__stack.enter_context(any_to_file_ptr(instream, "r"))
        c_directed = any_to_igraph_bool_t(directed)

        # Call wrapped function
        igraph_read_graph_dl(c_graph, c_instream, c_directed)

        # Prepare output arguments
        graph = _create_graph_from_boxed(c_graph)

        # Construct return value
        return graph

    # Help the type checker to figure out that we never get here
    assert False, "unreachable"  # noqa: B011


def write_graph_edgelist(graph: Graph, outstream: FileLike) -> None:
    """Writes the graph in plain edge list format to an output stream.

    The plain edge list format records the structure of the graph _only_ and the
    vertices of the graph will be referred to as numeric vertex IDs instead of
    vertex names.

    See `write_graph_ncol()` if you have vertex names and you want to use them
    in the output file instead of IDs.

    Parameters:
        graph: the graph to write
        outstream: the output file or stream to write the graph to. May be a
            filename, a path-like object or a file-like object if it is backed
            by a low-level file handle
    """
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))

        # Call wrapped function
        igraph_write_graph_edgelist(c_graph, c_outstream)


def write_graph_ncol(graph: Graph, outstream: FileLike, names: str = "name", weights: str = "weight") -> None:
    """Writes the graph in the NCOL format to an output stream.

    The NCOL format is essentially a two- or three-column named edge list format.
    Each line in the output corresponds to an edge. The first two columns contain
    the names of the source and target vertices of an edge. THe third column
    (if exists) contains the weight of each edge.

    Note that the file format does not store whether the graph is directed or not;
    this information has to be supplied when the graph is read back.

    Parameters:
        graph: the graph to write
        outstream: the output file or stream to write the graph to. May be a
            filename, a path-like object or a file-like object if it is backed
            by a low-level file handle
        names: name of the string vertex attribute that stores the names of the
            vertices to be written into the output file. A warning will be thrown if
            the attribute does not exist or is not a string attribute, and the file
            will contain numeric vertex IDs instead if this is the case.
        weights: name of the edge attribute that stores the weights of the edges
            to be written into the output file. A warning will be thrown if the
            attribute does not exist or is not a numeric attribute, and all weights
            will be assumed to be equal to 1 if this is the case.
    """
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))
        c_names = names.encode("utf-8")
        c_weights = weights.encode("utf-8")

        # Call wrapped function
        igraph_write_graph_ncol(c_graph, c_outstream, c_names, c_weights)


def write_graph_lgl(graph: Graph, outstream: FileLike, names: str = "name", weights: str = "weight", isolates: bool = True) -> None:
    """Writes the graph in the LGL (Large Graph Layout) format to an output stream.

    The LGL format can store the structure of a graph with named vertices and
    weighted edges.

    Note that the file format does not store whether the graph is directed or not;
    this information has to be supplied when the graph is read back.

    Parameters:
        graph: the graph to write
        outstream: the output file or stream to write the graph to. May be a
            filename, a path-like object or a file-like object if it is backed
            by a low-level file handle
        names: name of the string vertex attribute that stores the names of the
            vertices to be written into the output file. A warning will be thrown if
            the attribute does not exist or is not a string attribute, and the file
            will contain numeric vertex IDs instead if this is the case.
        weights: name of the edge attribute that stores the weights of the edges
            to be written into the output file. A warning will be thrown if the
            attribute does not exist or is not a numeric attribute, and all weights
            will be assumed to be equal to 1 if this is the case.
        isolates: whether to save isolated vertices to the output
    """
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))
        c_names = names.encode("utf-8")
        c_weights = weights.encode("utf-8")
        c_isolates = any_to_igraph_bool_t(isolates)

        # Call wrapped function
        igraph_write_graph_lgl(c_graph, c_outstream, c_names, c_weights, c_isolates)


def write_graph_leda(graph: Graph, outstream: FileLike, names: str = "name", weights: str = "weight") -> None:
    """Type-annotated wrapper for ``igraph_write_graph_leda``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))
        c_names = names.encode("utf-8")
        c_weights = weights.encode("utf-8")

        # Call wrapped function
        igraph_write_graph_leda(c_graph, c_outstream, c_names, c_weights)


def write_graph_graphml(graph: Graph, outstream: FileLike, prefixattr: bool = True) -> None:
    """Writes the graph in GraphML format to an output stream.

    The GraphML format preserves numeric, string and boolean attributes.

    Parameters:
        graph: the graph to write
        outstream: the output file or stream to write the graph to. May be a
            filename, a path-like object or a file-like object if it is backed
            by a low-level file handle
        prefixattr: whether to put a prefix in front of the attribute names to
            ensure uniqueness if the graph has vertex and edge (or graph)
            attributes with the same name
    """
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))
        c_prefixattr = any_to_igraph_bool_t(prefixattr)

        # Call wrapped function
        igraph_write_graph_graphml(c_graph, c_outstream, c_prefixattr)


def write_graph_pajek(graph: Graph, outstream: FileLike) -> None:
    """Type-annotated wrapper for ``igraph_write_graph_pajek``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))

        # Call wrapped function
        igraph_write_graph_pajek(c_graph, c_outstream)


def write_graph_dimacs_flow(graph: Graph, outstream: FileLike, capacity: Iterable[float], source: VertexLike = 0, target: VertexLike = 0) -> None:
    """Type-annotated wrapper for ``igraph_write_graph_dimacs_flow``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))
        c_source = vertexlike_to_igraph_integer_t(source)
        c_target = vertexlike_to_igraph_integer_t(target)
        c_capacity = iterable_to_igraph_vector_t_view(capacity)

        # Call wrapped function
        igraph_write_graph_dimacs_flow(c_graph, c_outstream, c_source, c_target, c_capacity)

# igraph_write_graph_gml: no Python type known for type: WRITE_GML_SW


def write_graph_dot(graph: Graph, outstream: FileLike) -> None:
    """Type-annotated wrapper for ``igraph_write_graph_dot``."""
    # Create exit stack for graceful cleanup
    with ExitStack() as py__stack:

        # Prepare input arguments
        c_graph = graph
        c_outstream = py__stack.enter_context(any_to_file_ptr(outstream, "w"))

        # Call wrapped function
        igraph_write_graph_dot(c_graph, c_outstream)


def motifs_randesu(graph: Graph, cut_prob: Iterable[float], size: int = 3) -> RealArray:
    """Type-annotated wrapper for ``igraph_motifs_randesu``."""
    # Prepare input arguments
    c_graph = graph
    c_hist = _Vector.create(0)
    c_size = size
    c_cut_prob = iterable_to_igraph_vector_t_view(cut_prob)

    # Call wrapped function
    igraph_motifs_randesu(c_graph, c_hist, c_size, c_cut_prob)

    # Prepare output arguments
    hist = igraph_vector_t_to_numpy_array(c_hist)

    # Construct return value
    return hist


def motifs_randesu_estimate(graph: Graph, cut_prob: Iterable[float], sample_size: int, size: int = 3, sample: Optional[Iterable[int]] = None) -> int:
    """Type-annotated wrapper for ``igraph_motifs_randesu_estimate``."""
    # Prepare input arguments
    c_graph = graph
    c_est = igraph_integer_t()
    c_size = size
    c_cut_prob = iterable_to_igraph_vector_t_view(cut_prob)
    c_sample_size = sample_size
    c_sample = iterable_to_igraph_vector_int_t_view(sample) if sample is not None else None

    # Call wrapped function
    igraph_motifs_randesu_estimate(c_graph, c_est, c_size, c_cut_prob, c_sample_size, c_sample)

    # Prepare output arguments
    est = c_est.value

    # Construct return value
    return est


def motifs_randesu_no(graph: Graph, cut_prob: Iterable[float], size: int = 3) -> int:
    """Type-annotated wrapper for ``igraph_motifs_randesu_no``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()
    c_size = size
    c_cut_prob = iterable_to_igraph_vector_t_view(cut_prob)

    # Call wrapped function
    igraph_motifs_randesu_no(c_graph, c_no, c_size, c_cut_prob)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no


def dyad_census(graph: Graph) -> tuple[float, float, float]:
    """Type-annotated wrapper for ``igraph_dyad_census``."""
    # Prepare input arguments
    c_graph = graph
    c_mut = igraph_real_t()
    c_asym = igraph_real_t()
    c_null = igraph_real_t()

    # Call wrapped function
    igraph_dyad_census(c_graph, c_mut, c_asym, c_null)

    # Prepare output arguments
    mut = c_mut.value
    asym = c_asym.value
    null = c_null.value

    # Construct return value
    return mut, asym, null


def triad_census(graph: Graph) -> RealArray:
    """Type-annotated wrapper for ``igraph_triad_census``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)

    # Call wrapped function
    igraph_triad_census(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def adjacent_triangles(graph: Graph, vids: VertexSelector = "all") -> RealArray:
    """Type-annotated wrapper for ``igraph_adjacent_triangles``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)

    # Call wrapped function
    igraph_adjacent_triangles(c_graph, c_res, c_vids.unwrap())

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_0(graph: Graph, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_0``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_scan_0(c_graph, c_res, c_weights, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_0_them(us: Graph, them: Graph, weights_them: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_0_them``."""
    # Prepare input arguments
    c_us = us
    c_them = them
    c_res = _Vector.create(0)
    c_weights_them = edge_weights_to_igraph_vector_t_view(weights_them, them)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_scan_0_them(c_us, c_them, c_res, c_weights_them, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_1_ecount(graph: Graph, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_1_ecount``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_scan_1_ecount(c_graph, c_res, c_weights, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_1_ecount_them(us: Graph, them: Graph, weights_them: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_1_ecount_them``."""
    # Prepare input arguments
    c_us = us
    c_them = them
    c_res = _Vector.create(0)
    c_weights_them = edge_weights_to_igraph_vector_t_view(weights_them, them)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_scan_1_ecount_them(c_us, c_them, c_res, c_weights_them, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_k_ecount(graph: Graph, k: int, weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_k_ecount``."""
    # Prepare input arguments
    c_graph = graph
    c_k = k
    c_res = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_scan_k_ecount(c_graph, c_k, c_res, c_weights, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_k_ecount_them(us: Graph, them: Graph, k: int, weights_them: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_k_ecount_them``."""
    # Prepare input arguments
    c_us = us
    c_them = them
    c_k = k
    c_res = _Vector.create(0)
    c_weights_them = edge_weights_to_igraph_vector_t_view(weights_them, them)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_local_scan_k_ecount_them(c_us, c_them, c_k, c_res, c_weights_them, c_mode)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_neighborhood_ecount(graph: Graph, neighborhoods: Iterable[Iterable[VertexLike]], weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_neighborhood_ecount``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_neighborhoods = iterable_of_vertex_index_iterable_to_igraph_vector_int_list_t(neighborhoods)

    # Call wrapped function
    igraph_local_scan_neighborhood_ecount(c_graph, c_res, c_weights, c_neighborhoods)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def local_scan_subset_ecount(graph: Graph, subsets: Iterable[Iterable[VertexLike]], weights: Optional[Iterable[float]] = None) -> RealArray:
    """Type-annotated wrapper for ``igraph_local_scan_subset_ecount``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_subsets = iterable_of_vertex_index_iterable_to_igraph_vector_int_list_t(subsets)

    # Call wrapped function
    igraph_local_scan_subset_ecount(c_graph, c_res, c_weights, c_subsets)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def list_triangles(graph: Graph) -> IntArray:
    """Type-annotated wrapper for ``igraph_list_triangles``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_list_triangles(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def disjoint_union(left: Graph, right: Graph) -> Graph:
    """Type-annotated wrapper for ``igraph_disjoint_union``."""
    # Prepare input arguments
    c_res = _Graph()
    c_left = left
    c_right = right

    # Call wrapped function
    igraph_disjoint_union(c_res, c_left, c_right)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res

# igraph_disjoint_union_many: no Python type known for type: GRAPH_PTR_LIST


def union(left: Graph, right: Graph) -> tuple[Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_union``."""
    # Prepare input arguments
    c_res = _Graph()
    c_left = left
    c_right = right
    c_edge_map_left = _VectorInt.create(0)
    c_edge_map_right = _VectorInt.create(0)

    # Call wrapped function
    igraph_union(c_res, c_left, c_right, c_edge_map_left, c_edge_map_right)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)
    edge_map_left = igraph_vector_int_t_to_numpy_array(c_edge_map_left)
    edge_map_right = igraph_vector_int_t_to_numpy_array(c_edge_map_right)

    # Construct return value
    return res, edge_map_left, edge_map_right

# igraph_union_many: no Python type known for type: GRAPH_PTR_LIST


def intersection(left: Graph, right: Graph) -> tuple[Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_intersection``."""
    # Prepare input arguments
    c_res = _Graph()
    c_left = left
    c_right = right
    c_edge_map_left = _VectorInt.create(0)
    c_edge_map_right = _VectorInt.create(0)

    # Call wrapped function
    igraph_intersection(c_res, c_left, c_right, c_edge_map_left, c_edge_map_right)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)
    edge_map_left = igraph_vector_int_t_to_numpy_array(c_edge_map_left)
    edge_map_right = igraph_vector_int_t_to_numpy_array(c_edge_map_right)

    # Construct return value
    return res, edge_map_left, edge_map_right

# igraph_intersection_many: no Python type known for type: GRAPH_PTR_LIST


def difference(orig: Graph, sub: Graph) -> Graph:
    """Type-annotated wrapper for ``igraph_difference``."""
    # Prepare input arguments
    c_res = _Graph()
    c_orig = orig
    c_sub = sub

    # Call wrapped function
    igraph_difference(c_res, c_orig, c_sub)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res


def complementer(graph: Graph, loops: bool = False) -> Graph:
    """Type-annotated wrapper for ``igraph_complementer``."""
    # Prepare input arguments
    c_res = _Graph()
    c_graph = graph
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_complementer(c_res, c_graph, c_loops)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res


def compose(g1: Graph, g2: Graph) -> tuple[Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_compose``."""
    # Prepare input arguments
    c_res = _Graph()
    c_g1 = g1
    c_g2 = g2
    c_edge_map1 = _VectorInt.create(0)
    c_edge_map2 = _VectorInt.create(0)

    # Call wrapped function
    igraph_compose(c_res, c_g1, c_g2, c_edge_map1, c_edge_map2)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)
    edge_map1 = igraph_vector_int_t_to_numpy_array(c_edge_map1)
    edge_map2 = igraph_vector_int_t_to_numpy_array(c_edge_map2)

    # Construct return value
    return res, edge_map1, edge_map2


def induced_subgraph_map(graph: Graph, vids: VertexSelector, impl: SubgraphImplementation) -> tuple[Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_induced_subgraph_map``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
    c_impl = c_int(impl)
    c_map = _VectorInt.create(0)
    c_invmap = _VectorInt.create(0)

    # Call wrapped function
    igraph_induced_subgraph_map(c_graph, c_res, c_vids.unwrap(), c_impl, c_map, c_invmap)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)
    map = igraph_vector_int_t_to_numpy_array(c_map)
    invmap = igraph_vector_int_t_to_numpy_array(c_invmap)

    # Construct return value
    return res, map, invmap


def gomory_hu_tree(graph: Graph, capacity: Optional[Iterable[float]] = None) -> tuple[Graph, RealArray]:
    """Type-annotated wrapper for ``igraph_gomory_hu_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_tree = _Graph()
    c_flows = _Vector.create(0)
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph) if capacity is not None else None

    # Call wrapped function
    igraph_gomory_hu_tree(c_graph, c_tree, c_flows, c_capacity)

    # Prepare output arguments
    tree = _create_graph_from_boxed(c_tree)
    flows = igraph_vector_t_to_numpy_array(c_flows)

    # Construct return value
    return tree, flows

# igraph_maxflow: no Python type known for type: MAXFLOW_STATS

# igraph_maxflow_value: no Python type known for type: MAXFLOW_STATS


def mincut(graph: Graph, capacity: Optional[Iterable[float]] = None) -> tuple[float, IntArray, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_mincut``."""
    # Prepare input arguments
    c_graph = graph
    c_value = igraph_real_t()
    c_partition1 = _VectorInt.create(0)
    c_partition2 = _VectorInt.create(0)
    c_cut = _VectorInt.create(0)
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph) if capacity is not None else None

    # Call wrapped function
    igraph_mincut(c_graph, c_value, c_partition1, c_partition2, c_cut, c_capacity)

    # Prepare output arguments
    value = c_value.value
    partition1 = igraph_vector_int_t_to_numpy_array(c_partition1)
    partition2 = igraph_vector_int_t_to_numpy_array(c_partition2)
    cut = igraph_vector_int_t_to_numpy_array(c_cut)

    # Construct return value
    return value, partition1, partition2, cut


def mincut_value(graph: Graph, capacity: Optional[Iterable[float]] = None) -> float:
    """Type-annotated wrapper for ``igraph_mincut_value``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph) if capacity is not None else None

    # Call wrapped function
    igraph_mincut_value(c_graph, c_res, c_capacity)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def residual_graph(graph: Graph, capacity: Iterable[float], flow: Iterable[float]) -> tuple[Graph, RealArray]:
    """Type-annotated wrapper for ``igraph_residual_graph``."""
    # Prepare input arguments
    c_graph = graph
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph)
    c_residual = _Graph()
    c_residual_capacity = _Vector.create(0)
    c_flow = iterable_to_igraph_vector_t_view(flow)

    # Call wrapped function
    igraph_residual_graph(c_graph, c_capacity, c_residual, c_residual_capacity, c_flow)

    # Prepare output arguments
    residual = _create_graph_from_boxed(c_residual)
    residual_capacity = igraph_vector_t_to_numpy_array(c_residual_capacity)

    # Construct return value
    return residual, residual_capacity


def reverse_residual_graph(graph: Graph, capacity: Iterable[float], flow: Iterable[float]) -> Graph:
    """Type-annotated wrapper for ``igraph_reverse_residual_graph``."""
    # Prepare input arguments
    c_graph = graph
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph)
    c_residual = _Graph()
    c_flow = iterable_to_igraph_vector_t_view(flow)

    # Call wrapped function
    igraph_reverse_residual_graph(c_graph, c_capacity, c_residual, c_flow)

    # Prepare output arguments
    residual = _create_graph_from_boxed(c_residual)

    # Construct return value
    return residual


def st_mincut(graph: Graph, source: VertexLike, target: VertexLike, capacity: Optional[Iterable[float]] = None) -> tuple[float, IntArray, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_st_mincut``."""
    # Prepare input arguments
    c_graph = graph
    c_value = igraph_real_t()
    c_cut = _VectorInt.create(0)
    c_partition1 = _VectorInt.create(0)
    c_partition2 = _VectorInt.create(0)
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph) if capacity is not None else None

    # Call wrapped function
    igraph_st_mincut(c_graph, c_value, c_cut, c_partition1, c_partition2, c_source, c_target, c_capacity)

    # Prepare output arguments
    value = c_value.value
    cut = igraph_vector_int_t_to_numpy_array(c_cut)
    partition1 = igraph_vector_int_t_to_numpy_array(c_partition1)
    partition2 = igraph_vector_int_t_to_numpy_array(c_partition2)

    # Construct return value
    return value, cut, partition1, partition2


def st_mincut_value(graph: Graph, source: VertexLike, target: VertexLike, capacity: Optional[Iterable[float]] = None) -> float:
    """Type-annotated wrapper for ``igraph_st_mincut_value``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph) if capacity is not None else None

    # Call wrapped function
    igraph_st_mincut_value(c_graph, c_res, c_source, c_target, c_capacity)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_st_vertex_connectivity: no Python type known for type: VCONNNEI


def vertex_connectivity(graph: Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_vertex_connectivity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_vertex_connectivity(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def st_edge_connectivity(graph: Graph, source: VertexLike, target: VertexLike) -> int:
    """Type-annotated wrapper for ``igraph_st_edge_connectivity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_st_edge_connectivity(c_graph, c_res, c_source, c_target)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def edge_connectivity(graph: Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_edge_connectivity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_edge_connectivity(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def edge_disjoint_paths(graph: Graph, source: VertexLike, target: VertexLike) -> int:
    """Type-annotated wrapper for ``igraph_edge_disjoint_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_edge_disjoint_paths(c_graph, c_res, c_source, c_target)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def vertex_disjoint_paths(graph: Graph, source: VertexLike, target: VertexLike) -> int:
    """Type-annotated wrapper for ``igraph_vertex_disjoint_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_vertex_disjoint_paths(c_graph, c_res, c_source, c_target)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def adhesion(graph: Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_adhesion``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_adhesion(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def cohesion(graph: Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_cohesion``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_cohesion(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def dominator_tree(graph: Graph, root: VertexLike, mode: NeighborMode = NeighborMode.OUT) -> tuple[IntArray, Graph, IntArray]:
    """Type-annotated wrapper for ``igraph_dominator_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_root = vertexlike_to_igraph_integer_t(root)
    c_dom = _VectorInt.create(0)
    c_domtree = _Graph()
    c_leftout = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_dominator_tree(c_graph, c_root, c_dom, c_domtree, c_leftout, c_mode)

    # Prepare output arguments
    dom = igraph_vector_int_t_to_numpy_array(c_dom)
    domtree = _create_graph_from_boxed(c_domtree)
    leftout = igraph_vector_int_t_to_numpy_array(c_leftout)

    # Construct return value
    return dom, domtree, leftout


def all_st_cuts(graph: Graph, source: VertexLike, target: VertexLike) -> tuple[list[IntArray], list[IntArray]]:
    """Type-annotated wrapper for ``igraph_all_st_cuts``."""
    # Prepare input arguments
    c_graph = graph
    c_cuts = _VectorIntList.create(0)
    c_partition1s = _VectorIntList.create(0)
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_all_st_cuts(c_graph, c_cuts, c_partition1s, c_source, c_target)

    # Prepare output arguments
    cuts = igraph_vector_int_list_t_to_list_of_numpy_array(c_cuts)
    partition1s = igraph_vector_int_list_t_to_list_of_numpy_array(c_partition1s)

    # Construct return value
    return cuts, partition1s


def all_st_mincuts(graph: Graph, source: VertexLike, target: VertexLike, capacity: Optional[Iterable[float]] = None) -> tuple[float, list[IntArray], list[IntArray]]:
    """Type-annotated wrapper for ``igraph_all_st_mincuts``."""
    # Prepare input arguments
    c_graph = graph
    c_value = igraph_real_t()
    c_cuts = _VectorIntList.create(0)
    c_partition1s = _VectorIntList.create(0)
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)
    c_capacity = edge_capacities_to_igraph_vector_t_view(capacity, graph) if capacity is not None else None

    # Call wrapped function
    igraph_all_st_mincuts(c_graph, c_value, c_cuts, c_partition1s, c_source, c_target, c_capacity)

    # Prepare output arguments
    value = c_value.value
    cuts = igraph_vector_int_list_t_to_list_of_numpy_array(c_cuts)
    partition1s = igraph_vector_int_list_t_to_list_of_numpy_array(c_partition1s)

    # Construct return value
    return value, cuts, partition1s


def even_tarjan_reduction(graph: Graph) -> tuple[Graph, RealArray]:
    """Type-annotated wrapper for ``igraph_even_tarjan_reduction``."""
    # Prepare input arguments
    c_graph = graph
    c_graphbar = _Graph()
    c_capacity = _Vector.create(0)

    # Call wrapped function
    igraph_even_tarjan_reduction(c_graph, c_graphbar, c_capacity)

    # Prepare output arguments
    graphbar = _create_graph_from_boxed(c_graphbar)
    capacity = igraph_vector_t_to_numpy_array(c_capacity)

    # Construct return value
    return graphbar, capacity


def is_separator(graph: Graph, candidate: VertexSelector) -> bool:
    """Type-annotated wrapper for ``igraph_is_separator``."""
    # Prepare input arguments
    c_graph = graph
    c_candidate = vertex_selector_to_igraph_vs_t(candidate, graph)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_separator(c_graph, c_candidate.unwrap(), c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_minimal_separator(graph: Graph, candidate: VertexSelector) -> bool:
    """Type-annotated wrapper for ``igraph_is_minimal_separator``."""
    # Prepare input arguments
    c_graph = graph
    c_candidate = vertex_selector_to_igraph_vs_t(candidate, graph)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_minimal_separator(c_graph, c_candidate.unwrap(), c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def all_minimal_st_separators(graph: Graph) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_all_minimal_st_separators``."""
    # Prepare input arguments
    c_graph = graph
    c_separators = _VectorIntList.create(0)

    # Call wrapped function
    igraph_all_minimal_st_separators(c_graph, c_separators)

    # Prepare output arguments
    separators = igraph_vector_int_list_t_to_list_of_numpy_array(c_separators)

    # Construct return value
    return separators


def minimum_size_separators(graph: Graph) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_minimum_size_separators``."""
    # Prepare input arguments
    c_graph = graph
    c_separators = _VectorIntList.create(0)

    # Call wrapped function
    igraph_minimum_size_separators(c_graph, c_separators)

    # Prepare output arguments
    separators = igraph_vector_int_list_t_to_list_of_numpy_array(c_separators)

    # Construct return value
    return separators


def cohesive_blocks(graph: Graph) -> tuple[list[IntArray], IntArray, IntArray, Graph]:
    """Type-annotated wrapper for ``igraph_cohesive_blocks``."""
    # Prepare input arguments
    c_graph = graph
    c_blocks = _VectorIntList.create(0)
    c_cohesion = _VectorInt.create(0)
    c_parent = _VectorInt.create(0)
    c_blockTree = _Graph()

    # Call wrapped function
    igraph_cohesive_blocks(c_graph, c_blocks, c_cohesion, c_parent, c_blockTree)

    # Prepare output arguments
    blocks = igraph_vector_int_list_t_to_list_of_numpy_array(c_blocks)
    cohesion = igraph_vector_int_t_to_numpy_array(c_cohesion)
    parent = igraph_vector_int_t_to_numpy_array(c_parent)
    blockTree = _create_graph_from_boxed(c_blockTree)

    # Construct return value
    return blocks, cohesion, parent, blockTree


def coreness(graph: Graph, mode: NeighborMode = NeighborMode.ALL) -> IntArray:
    """Type-annotated wrapper for ``igraph_coreness``."""
    # Prepare input arguments
    c_graph = graph
    c_cores = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_coreness(c_graph, c_cores, c_mode)

    # Prepare output arguments
    cores = igraph_vector_int_t_to_numpy_array(c_cores)

    # Construct return value
    return cores


def isoclass(graph: Graph) -> int:
    """Type-annotated wrapper for ``igraph_isoclass``."""
    # Prepare input arguments
    c_graph = graph
    c_isoclass = igraph_integer_t()

    # Call wrapped function
    igraph_isoclass(c_graph, c_isoclass)

    # Prepare output arguments
    isoclass = c_isoclass.value

    # Construct return value
    return isoclass


def isomorphic(graph1: Graph, graph2: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_isomorphic``."""
    # Prepare input arguments
    c_graph1 = graph1
    c_graph2 = graph2
    c_iso = igraph_bool_t()

    # Call wrapped function
    igraph_isomorphic(c_graph1, c_graph2, c_iso)

    # Prepare output arguments
    iso = c_iso.value

    # Construct return value
    return iso


def isoclass_subgraph(graph: Graph, vids: Iterable[int]) -> int:
    """Type-annotated wrapper for ``igraph_isoclass_subgraph``."""
    # Prepare input arguments
    c_graph = graph
    c_vids = iterable_to_igraph_vector_int_t_view(vids)
    c_isoclass = igraph_integer_t()

    # Call wrapped function
    igraph_isoclass_subgraph(c_graph, c_vids, c_isoclass)

    # Prepare output arguments
    isoclass = c_isoclass.value

    # Construct return value
    return isoclass


def isoclass_create(size: int, number: int, directed: bool = True) -> Graph:
    """Type-annotated wrapper for ``igraph_isoclass_create``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_size = size
    c_number = number
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_isoclass_create(c_graph, c_size, c_number, c_directed)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph

# igraph_isomorphic_vf2: no Python type known for type: ISOCOMPAT_FUNC

# igraph_count_isomorphisms_vf2: no Python type known for type: ISOCOMPAT_FUNC

# igraph_get_isomorphisms_vf2: no Python type known for type: VECTOR_INT_LIST


def subisomorphic(graph1: Graph, graph2: Graph) -> bool:
    """Type-annotated wrapper for ``igraph_subisomorphic``."""
    # Prepare input arguments
    c_graph1 = graph1
    c_graph2 = graph2
    c_iso = igraph_bool_t()

    # Call wrapped function
    igraph_subisomorphic(c_graph1, c_graph2, c_iso)

    # Prepare output arguments
    iso = c_iso.value

    # Construct return value
    return iso

# igraph_subisomorphic_vf2: no Python type known for type: ISOCOMPAT_FUNC

# igraph_subisomorphic_function_vf2: no Python type known for type: ISOMORPHISM_FUNC

# igraph_count_subisomorphisms_vf2: no Python type known for type: ISOCOMPAT_FUNC

# igraph_get_subisomorphisms_vf2: no Python type known for type: VECTOR_INT_LIST

# igraph_canonical_permutation: no Python type known for type: BLISSSH


def permute_vertices(graph: Graph, permutation: Iterable[int]) -> Graph:
    """Type-annotated wrapper for ``igraph_permute_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_permutation = iterable_to_igraph_vector_int_t_view(permutation)

    # Call wrapped function
    igraph_permute_vertices(c_graph, c_res, c_permutation)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)

    # Construct return value
    return res

# igraph_isomorphic_bliss: no Python type known for type: BLISSSH

# igraph_automorphisms: no Python type known for type: BLISSSH

# igraph_automorphism_group: no Python type known for type: BLISSSH

# igraph_subisomorphic_lad: no Python type known for type: VECTOR_INT_LIST


def simplify_and_colorize(graph: Graph) -> tuple[Graph, IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_simplify_and_colorize``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_vertex_color = _VectorInt.create(0)
    c_edge_color = _VectorInt.create(0)

    # Call wrapped function
    igraph_simplify_and_colorize(c_graph, c_res, c_vertex_color, c_edge_color)

    # Prepare output arguments
    res = _create_graph_from_boxed(c_res)
    vertex_color = igraph_vector_int_t_to_numpy_array(c_vertex_color)
    edge_color = igraph_vector_int_t_to_numpy_array(c_edge_color)

    # Construct return value
    return res, vertex_color, edge_color


def graph_count(n: int, directed: bool = False) -> int:
    """Type-annotated wrapper for ``igraph_graph_count``."""
    # Prepare input arguments
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_count = igraph_integer_t()

    # Call wrapped function
    igraph_graph_count(c_n, c_directed, c_count)

    # Prepare output arguments
    count = c_count.value

    # Construct return value
    return count


def is_matching(graph: Graph, matching: Iterable[int], types: Optional[Iterable[Any]] = None) -> bool:
    """Type-annotated wrapper for ``igraph_is_matching``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None if types is not None else None
    c_matching = iterable_to_igraph_vector_int_t_view(matching)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_matching(c_graph, c_types, c_matching, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_maximal_matching(graph: Graph, matching: Iterable[int], types: Optional[Iterable[Any]] = None) -> bool:
    """Type-annotated wrapper for ``igraph_is_maximal_matching``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_bool_t_view(types) if types is not None else None if types is not None else None
    c_matching = iterable_to_igraph_vector_int_t_view(matching)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_maximal_matching(c_graph, c_types, c_matching, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_adjacency_spectral_embedding: no Python type known for type: EIGENWHICHPOS

# igraph_laplacian_spectral_embedding: no Python type known for type: EIGENWHICHPOS

# igraph_eigen_adjacency: no Python type known for type: EIGENWHICH

# igraph_power_law_fit: no Python type known for type: PLFIT

# igraph_sir: no Python type known for type: SIR_LIST


def running_mean(data: Iterable[float], binwidth: int) -> RealArray:
    """Type-annotated wrapper for ``igraph_running_mean``."""
    # Prepare input arguments
    c_data = iterable_to_igraph_vector_t_view(data)
    c_res = _Vector.create(0)
    c_binwidth = binwidth

    # Call wrapped function
    igraph_running_mean(c_data, c_res, c_binwidth)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def random_sample(l: int, h: int, length: int) -> IntArray:
    """Type-annotated wrapper for ``igraph_random_sample``."""
    # Prepare input arguments
    c_res = _VectorInt.create(0)
    c_l = l
    c_h = h
    c_length = length

    # Call wrapped function
    igraph_random_sample(c_res, c_l, c_h, c_length)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def convex_hull(data: MatrixLike) -> tuple[IntArray, RealArray]:
    """Type-annotated wrapper for ``igraph_convex_hull``."""
    # Prepare input arguments
    c_data = sequence_to_igraph_matrix_t_view(data)
    c_resverts = _VectorInt.create(0)
    c_rescoords = _Matrix.create(0)

    # Call wrapped function
    igraph_convex_hull(c_data, c_resverts, c_rescoords)

    # Prepare output arguments
    resverts = igraph_vector_int_t_to_numpy_array(c_resverts)
    rescoords = igraph_matrix_t_to_numpy_array(c_rescoords)

    # Construct return value
    return resverts, rescoords


def dim_select(sv: Iterable[float]) -> int:
    """Type-annotated wrapper for ``igraph_dim_select``."""
    # Prepare input arguments
    c_sv = iterable_to_igraph_vector_t_view(sv)
    c_dim = igraph_integer_t()

    # Call wrapped function
    igraph_dim_select(c_sv, c_dim)

    # Prepare output arguments
    dim = c_dim.value

    # Construct return value
    return dim


def almost_equals(a: float, b: float, eps: float) -> bool:
    """Type-annotated wrapper for ``igraph_almost_equals``."""
    # Prepare input arguments
    c_a = a
    c_b = b
    c_eps = eps

    # Call wrapped function
    c__result = igraph_almost_equals(c_a, c_b, c_eps)

    # Construct return value
    return c__result


def cmp_epsilon(a: float, b: float, eps: float) -> int:
    """Type-annotated wrapper for ``igraph_cmp_epsilon``."""
    # Prepare input arguments
    c_a = a
    c_b = b
    c_eps = eps

    # Call wrapped function
    c__result = igraph_cmp_epsilon(c_a, c_b, c_eps)

    # Construct return value
    return c__result

# igraph_eigen_matrix: no Python type known for type: SPARSEMAT

# igraph_eigen_matrix_symmetric: no Python type known for type: SPARSEMAT


def solve_lsap(c: MatrixLike, n: int) -> IntArray:
    """Type-annotated wrapper for ``igraph_solve_lsap``."""
    # Prepare input arguments
    c_c = sequence_to_igraph_matrix_t_view(c)
    c_n = n
    c_p = _VectorInt.create(0)

    # Call wrapped function
    igraph_solve_lsap(c_c, c_n, c_p)

    # Prepare output arguments
    p = igraph_vector_int_t_to_numpy_array(c_p)

    # Construct return value
    return p


def is_eulerian(graph: Graph) -> tuple[bool, bool]:
    """Type-annotated wrapper for ``igraph_is_eulerian``."""
    # Prepare input arguments
    c_graph = graph
    c_has_path = igraph_bool_t()
    c_has_cycle = igraph_bool_t()

    # Call wrapped function
    igraph_is_eulerian(c_graph, c_has_path, c_has_cycle)

    # Prepare output arguments
    has_path = c_has_path.value
    has_cycle = c_has_cycle.value

    # Construct return value
    return has_path, has_cycle


def eulerian_path(graph: Graph) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_eulerian_path``."""
    # Prepare input arguments
    c_graph = graph
    c_edge_res = _VectorInt.create(0)
    c_vertex_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_eulerian_path(c_graph, c_edge_res, c_vertex_res)

    # Prepare output arguments
    edge_res = igraph_vector_int_t_to_numpy_array(c_edge_res)
    vertex_res = igraph_vector_int_t_to_numpy_array(c_vertex_res)

    # Construct return value
    return edge_res, vertex_res


def eulerian_cycle(graph: Graph) -> tuple[IntArray, IntArray]:
    """Type-annotated wrapper for ``igraph_eulerian_cycle``."""
    # Prepare input arguments
    c_graph = graph
    c_edge_res = _VectorInt.create(0)
    c_vertex_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_eulerian_cycle(c_graph, c_edge_res, c_vertex_res)

    # Prepare output arguments
    edge_res = igraph_vector_int_t_to_numpy_array(c_edge_res)
    vertex_res = igraph_vector_int_t_to_numpy_array(c_vertex_res)

    # Construct return value
    return edge_res, vertex_res


def fundamental_cycles(graph: Graph, bfs_cutoff: int, start: Optional[VertexLike] = None, weights: Optional[Iterable[float]] = None) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_fundamental_cycles``."""
    # Prepare input arguments
    c_graph = graph
    c_basis = _VectorIntList.create(0)
    c_start = vertexlike_to_igraph_integer_t(start) if start is not None else None
    c_bfs_cutoff = bfs_cutoff
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_fundamental_cycles(c_graph, c_basis, c_start, c_bfs_cutoff, c_weights)

    # Prepare output arguments
    basis = igraph_vector_int_list_t_to_list_of_numpy_array(c_basis)

    # Construct return value
    return basis


def minimum_cycle_basis(graph: Graph, bfs_cutoff: int, complete: bool, use_cycle_order: bool, weights: Optional[Iterable[float]] = None) -> list[IntArray]:
    """Type-annotated wrapper for ``igraph_minimum_cycle_basis``."""
    # Prepare input arguments
    c_graph = graph
    c_basis = _VectorIntList.create(0)
    c_bfs_cutoff = bfs_cutoff
    c_complete = any_to_igraph_bool_t(complete)
    c_use_cycle_order = any_to_igraph_bool_t(use_cycle_order)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_minimum_cycle_basis(c_graph, c_basis, c_bfs_cutoff, c_complete, c_use_cycle_order, c_weights)

    # Prepare output arguments
    basis = igraph_vector_int_list_t_to_list_of_numpy_array(c_basis)

    # Construct return value
    return basis


def is_tree(graph: Graph, mode: NeighborMode = NeighborMode.OUT) -> tuple[bool, int]:
    """Type-annotated wrapper for ``igraph_is_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_root = igraph_integer_t(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_is_tree(c_graph, c_res, c_root, c_mode)

    # Prepare output arguments
    res = c_res.value
    root = c_root.value

    # Construct return value
    return res, root


def is_forest(graph: Graph, mode: NeighborMode = NeighborMode.OUT) -> tuple[bool, IntArray]:
    """Type-annotated wrapper for ``igraph_is_forest``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_roots = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_is_forest(c_graph, c_res, c_roots, c_mode)

    # Prepare output arguments
    res = c_res.value
    roots = igraph_vector_int_t_to_numpy_array(c_roots)

    # Construct return value
    return res, roots


def from_prufer(prufer: Iterable[int]) -> Graph:
    """Type-annotated wrapper for ``igraph_from_prufer``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_prufer = iterable_to_igraph_vector_int_t_view(prufer)

    # Call wrapped function
    igraph_from_prufer(c_graph, c_prufer)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def to_prufer(graph: Graph) -> IntArray:
    """Type-annotated wrapper for ``igraph_to_prufer``."""
    # Prepare input arguments
    c_graph = graph
    c_prufer = _VectorInt.create(0)

    # Call wrapped function
    igraph_to_prufer(c_graph, c_prufer)

    # Prepare output arguments
    prufer = igraph_vector_int_t_to_numpy_array(c_prufer)

    # Construct return value
    return prufer


def tree_from_parent_vector(parents: Iterable[int], type: TreeMode = TreeMode.OUT) -> Graph:
    """Type-annotated wrapper for ``igraph_tree_from_parent_vector``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_parents = iterable_to_igraph_vector_int_t_view(parents)
    c_type = c_int(type)

    # Call wrapped function
    igraph_tree_from_parent_vector(c_graph, c_parents, c_type)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def minimum_spanning_tree(graph: Graph, weights: Optional[Iterable[float]] = None) -> IntArray:
    """Type-annotated wrapper for ``igraph_minimum_spanning_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_minimum_spanning_tree(c_graph, c_res, c_weights)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def minimum_spanning_tree_unweighted(graph: Graph) -> Graph:
    """Type-annotated wrapper for ``igraph_minimum_spanning_tree_unweighted``."""
    # Prepare input arguments
    c_graph = graph
    c_mst = _Graph()

    # Call wrapped function
    igraph_minimum_spanning_tree_unweighted(c_graph, c_mst)

    # Prepare output arguments
    mst = _create_graph_from_boxed(c_mst)

    # Construct return value
    return mst


def minimum_spanning_tree_prim(graph: Graph, weights: Iterable[float]) -> Graph:
    """Type-annotated wrapper for ``igraph_minimum_spanning_tree_prim``."""
    # Prepare input arguments
    c_graph = graph
    c_mst = _Graph()
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)

    # Call wrapped function
    igraph_minimum_spanning_tree_prim(c_graph, c_mst, c_weights)

    # Prepare output arguments
    mst = _create_graph_from_boxed(c_mst)

    # Construct return value
    return mst


def random_spanning_tree(graph: Graph, vid: Optional[VertexLike] = None) -> IntArray:
    """Type-annotated wrapper for ``igraph_random_spanning_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid) if vid is not None else None

    # Call wrapped function
    igraph_random_spanning_tree(c_graph, c_res, c_vid)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def tree_game(n: int, directed: bool = False, method: RandomTreeMethod = RandomTreeMethod.LERW) -> Graph:
    """Type-annotated wrapper for ``igraph_tree_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_method = c_int(method)

    # Call wrapped function
    igraph_tree_game(c_graph, c_n, c_directed, c_method)

    # Prepare output arguments
    graph = _create_graph_from_boxed(c_graph)

    # Construct return value
    return graph


def vertex_coloring_greedy(graph: Graph, heuristic: GreedyColoringHeuristics = GreedyColoringHeuristics.NEIGHBORS) -> IntArray:
    """Type-annotated wrapper for ``igraph_vertex_coloring_greedy``."""
    # Prepare input arguments
    c_graph = graph
    c_colors = _VectorInt.create(0)
    c_heuristic = c_int(heuristic)

    # Call wrapped function
    igraph_vertex_coloring_greedy(c_graph, c_colors, c_heuristic)

    # Prepare output arguments
    colors = igraph_vector_int_t_to_numpy_array(c_colors)

    # Construct return value
    return colors


def deterministic_optimal_imitation(graph: Graph, vid: VertexLike, quantities: Iterable[float], strategies: Iterable[int], optimality: Optimality = Optimality.MAXIMUM, mode: NeighborMode = NeighborMode.OUT) -> None:
    """Type-annotated wrapper for ``igraph_deterministic_optimal_imitation``."""
    # Prepare input arguments
    c_graph = graph
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_optimality = c_int(optimality)
    c_quantities = vertex_qtys_to_igraph_vector_t_view(quantities, graph)
    c_strategies = iterable_to_igraph_vector_int_t(strategies)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_deterministic_optimal_imitation(c_graph, c_vid, c_optimality, c_quantities, c_strategies, c_mode)

    # Prepare output arguments
    strategies = igraph_vector_int_t_to_numpy_array(c_strategies)


def moran_process(graph: Graph, quantities: Iterable[float], strategies: Iterable[int], weights: Optional[Iterable[float]] = None, mode: NeighborMode = NeighborMode.OUT) -> None:
    """Type-annotated wrapper for ``igraph_moran_process``."""
    # Prepare input arguments
    c_graph = graph
    c_weights = edge_weights_to_igraph_vector_t_view(weights, graph)
    c_quantities = vertex_qtys_to_igraph_vector_t(quantities, graph)
    c_strategies = iterable_to_igraph_vector_int_t(strategies)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_moran_process(c_graph, c_weights, c_quantities, c_strategies, c_mode)

    # Prepare output arguments
    quantities = igraph_vector_t_to_numpy_array(c_quantities)
    strategies = igraph_vector_int_t_to_numpy_array(c_strategies)


def roulette_wheel_imitation(graph: Graph, vid: VertexLike, is_local: bool, quantities: Iterable[float], strategies: Iterable[int], mode: NeighborMode = NeighborMode.OUT) -> None:
    """Type-annotated wrapper for ``igraph_roulette_wheel_imitation``."""
    # Prepare input arguments
    c_graph = graph
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_is_local = any_to_igraph_bool_t(is_local)
    c_quantities = vertex_qtys_to_igraph_vector_t_view(quantities, graph)
    c_strategies = iterable_to_igraph_vector_int_t(strategies)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_roulette_wheel_imitation(c_graph, c_vid, c_is_local, c_quantities, c_strategies, c_mode)

    # Prepare output arguments
    strategies = igraph_vector_int_t_to_numpy_array(c_strategies)


def stochastic_imitation(graph: Graph, vid: VertexLike, algo: ImitateAlgorithm, quantities: Iterable[float], strategies: Iterable[int], mode: NeighborMode = NeighborMode.OUT) -> None:
    """Type-annotated wrapper for ``igraph_stochastic_imitation``."""
    # Prepare input arguments
    c_graph = graph
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_algo = c_int(algo)
    c_quantities = vertex_qtys_to_igraph_vector_t_view(quantities, graph)
    c_strategies = iterable_to_igraph_vector_int_t(strategies)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_stochastic_imitation(c_graph, c_vid, c_algo, c_quantities, c_strategies, c_mode)

    # Prepare output arguments
    strategies = igraph_vector_int_t_to_numpy_array(c_strategies)


def convergence_degree(graph: Graph) -> tuple[RealArray, RealArray, RealArray]:
    """Type-annotated wrapper for ``igraph_convergence_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_result = _Vector.create(0)
    c_in = _Vector.create(0)
    c_out = _Vector.create(0)

    # Call wrapped function
    igraph_convergence_degree(c_graph, c_result, c_in, c_out)

    # Prepare output arguments
    result = igraph_vector_t_to_numpy_array(c_result)
    in_ = igraph_vector_t_to_numpy_array(c_in)
    out = igraph_vector_t_to_numpy_array(c_out)

    # Construct return value
    return result, in_, out


def has_attribute_table() -> bool:
    """Type-annotated wrapper for ``igraph_has_attribute_table``."""
    # Call wrapped function
    c__result = igraph_has_attribute_table()

    # Construct return value
    return c__result

# igraph_progress: no Python type known for type: EXTRA

# igraph_status: no Python type known for type: EXTRA


def strerror(igraph_errno: int) -> str:
    """Type-annotated wrapper for ``igraph_strerror``."""
    # Prepare input arguments
    c_igraph_errno = igraph_errno

    # Call wrapped function
    c__result = igraph_strerror(c_igraph_errno)

    # Prepare return value
    py__result = bytes_to_str(c__result)

    # Construct return value
    return py__result


def expand_path_to_pairs(path: Iterable[VertexLike]) -> None:
    """Type-annotated wrapper for ``igraph_expand_path_to_pairs``."""
    # Prepare input arguments
    c_path = iterable_vertex_indices_to_igraph_vector_int_t(path)

    # Call wrapped function
    igraph_expand_path_to_pairs(c_path)

    # Prepare output arguments
    path = igraph_vector_int_t_to_numpy_array(c_path)


def invalidate_cache(graph: Graph) -> None:
    """Type-annotated wrapper for ``igraph_invalidate_cache``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    igraph_invalidate_cache(c_graph)


def vertex_path_from_edge_path(graph: Graph, start: VertexLike, edge_path: Iterable[EdgeLike], mode: NeighborMode = NeighborMode.OUT) -> IntArray:
    """Type-annotated wrapper for ``igraph_vertex_path_from_edge_path``."""
    # Prepare input arguments
    c_graph = graph
    c_start = vertexlike_to_igraph_integer_t(start)
    c_edge_path = iterable_edge_indices_to_igraph_vector_int_t(edge_path)
    c_vertex_path = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_vertex_path_from_edge_path(c_graph, c_start, c_edge_path, c_vertex_path, c_mode)

    # Prepare output arguments
    vertex_path = igraph_vector_int_t_to_numpy_array(c_vertex_path)

    # Construct return value
    return vertex_path


def version() -> tuple[str, int, int, int]:
    """Type-annotated wrapper for ``igraph_version``."""
    # Prepare input arguments
    c_version_string = c_char_p()
    c_major = c_int()
    c_minor = c_int()
    c_subminor = c_int()

    # Call wrapped function
    igraph_version(c_version_string, c_major, c_minor, c_subminor)

    # Prepare output arguments
    version_string = bytes_to_str(c_version_string)
    major = c_major.value
    minor = c_minor.value
    subminor = c_subminor.value

    # Construct return value
    return version_string, major, minor, subminor
