import numpy as np
import numpy.typing as npt

from typing import Iterable, Optional, Tuple

from .conversion import *  # noqa
from .enums import *  # noqa
from .lib import *  # noqa
from .types import EdgeLike, EdgeSelector, VertexLike, VertexPair, VertexSelector
from .wrappers import _Graph, _Vector, _VectorBool, _VectorInt


# The rest of this file is generated by Stimulus


def empty(n: int = 0, directed: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_empty``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_empty(c_graph, c_n, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def add_edges(graph: _Graph, edges: Iterable[VertexPair]) -> None:
    """Type-annotated wrapper for ``igraph_add_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_edges = vertex_pairs_to_igraph_vector_int_t(edges)
    c_attr = None

    # Call wrapped function
    igraph_add_edges(c_graph, c_edges, c_attr)


def add_vertices(graph: _Graph, nv: int) -> None:
    """Type-annotated wrapper for ``igraph_add_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_nv = nv
    c_attr = None

    # Call wrapped function
    igraph_add_vertices(c_graph, c_nv, c_attr)


def copy(from_: _Graph) -> _Graph:
    """Type-annotated wrapper for ``igraph_copy``."""
    # Prepare input arguments
    c_to = _Graph()
    c_from = from_

    # Call wrapped function
    igraph_copy(c_to, c_from)

    # Prepare output arguments
    to = c_to.mark_initialized()

    # Construct return value
    return to


def delete_edges(graph: _Graph, edges: EdgeSelector) -> None:
    """Type-annotated wrapper for ``igraph_delete_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_edges = edge_selector_to_igraph_es_t(edges, c_graph)

    # Call wrapped function
    igraph_delete_edges(c_graph, c_edges)


def delete_vertices(graph: _Graph, vertices: VertexSelector) -> None:
    """Type-annotated wrapper for ``igraph_delete_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = vertex_selector_to_igraph_vs_t(vertices, c_graph)

    # Call wrapped function
    igraph_delete_vertices(c_graph, c_vertices)


def delete_vertices_idx(graph: _Graph, vertices: VertexSelector) -> Tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_delete_vertices_idx``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = vertex_selector_to_igraph_vs_t(vertices, c_graph)
    c_idx = _VectorInt.create(0)
    c_invidx = _VectorInt.create(0)

    # Call wrapped function
    igraph_delete_vertices_idx(c_graph, c_vertices, c_idx, c_invidx)

    # Prepare output arguments
    idx = igraph_vector_int_t_to_numpy_array(c_idx)
    invidx = igraph_vector_int_t_to_numpy_array(c_invidx)

    # Construct return value
    return idx, invidx


def vcount(graph: _Graph) -> int:
    """Type-annotated wrapper for ``igraph_vcount``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    c__result = igraph_vcount(c_graph)

    # Construct return value
    return c__result


def ecount(graph: _Graph) -> int:
    """Type-annotated wrapper for ``igraph_ecount``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    c__result = igraph_ecount(c_graph)

    # Construct return value
    return c__result


def neighbors(graph: _Graph, vid: VertexLike, mode: NeighborMode = NeighborMode.ALL) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_neighbors``."""
    # Prepare input arguments
    c_graph = graph
    c_neis = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_neighbors(c_graph, c_neis, c_vid, c_mode)

    # Prepare output arguments
    neis = igraph_vector_int_t_to_numpy_array(c_neis)

    # Construct return value
    return neis


def is_directed(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_directed``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    c__result = igraph_is_directed(c_graph)

    # Construct return value
    return c__result

# igraph_degree: at least one default argument precedes non-default argument loops


def edge(graph: _Graph, eid: int) -> Tuple[int, int]:
    """Type-annotated wrapper for ``igraph_edge``."""
    # Prepare input arguments
    c_graph = graph
    c_eid = eid
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()

    # Call wrapped function
    igraph_edge(c_graph, c_eid, c_from, c_to)

    # Prepare output arguments
    from_ = c_from.value
    to = c_to.value

    # Construct return value
    return from_, to


def edges(graph: _Graph, eids: EdgeSelector) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = edge_selector_to_igraph_es_t(eids, c_graph)
    c_edges = _VectorInt.create(0)

    # Call wrapped function
    igraph_edges(c_graph, c_eids, c_edges)

    # Prepare output arguments
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return edges


def get_eid(graph: _Graph, from_: VertexLike, to: VertexLike, directed: bool = True, error: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_get_eid``."""
    # Prepare input arguments
    c_graph = graph
    c_eid = igraph_integer_t(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_directed = any_to_igraph_bool_t(directed)
    c_error = any_to_igraph_bool_t(error)

    # Call wrapped function
    igraph_get_eid(c_graph, c_eid, c_from, c_to, c_directed, c_error)

    # Prepare output arguments
    eid = c_eid.value

    # Construct return value
    return eid


def get_eids(graph: _Graph, pairs: Iterable[VertexPair], directed: bool = True, error: bool = True) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_get_eids``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = _VectorInt.create(0)
    c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
    c_directed = any_to_igraph_bool_t(directed)
    c_error = any_to_igraph_bool_t(error)

    # Call wrapped function
    igraph_get_eids(c_graph, c_eids, c_pairs, c_directed, c_error)

    # Prepare output arguments
    eids = igraph_vector_int_t_to_numpy_array(c_eids)

    # Construct return value
    return eids


def get_all_eids_between(graph: _Graph, from_: VertexLike, to: VertexLike, directed: bool = True) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_get_all_eids_between``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_get_all_eids_between(c_graph, c_eids, c_from, c_to, c_directed)

    # Prepare output arguments
    eids = igraph_vector_int_t_to_numpy_array(c_eids)

    # Construct return value
    return eids


def incident(graph: _Graph, vid: VertexLike, mode: NeighborMode = NeighborMode.ALL) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_incident``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_incident(c_graph, c_eids, c_vid, c_mode)

    # Prepare output arguments
    eids = igraph_vector_int_t_to_numpy_array(c_eids)

    # Construct return value
    return eids


def is_same_graph(graph1: _Graph, graph2: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_same_graph``."""
    # Prepare input arguments
    c_graph1 = graph1
    c_graph2 = graph2
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_same_graph(c_graph1, c_graph2, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def create(edges: Iterable[int], n: int = 0, directed: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_create``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_edges = iterable_to_igraph_vector_int_t_view(edges)
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_create(c_graph, c_edges, c_n, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_adjacency: no Python type known for type: MATRIX

# igraph_sparse_adjacency: no Python type known for type: SPARSEMAT

# igraph_sparse_weighted_adjacency: no Python type known for type: SPARSEMAT

# igraph_weighted_adjacency: no Python type known for type: MATRIX


def star(n: int, mode: StarMode = StarMode.OUT, center: int = 0) -> _Graph:
    """Type-annotated wrapper for ``igraph_star``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_mode = c_int(mode)
    c_center = center

    # Call wrapped function
    igraph_star(c_graph, c_n, c_mode, c_center)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def wheel(n: int, mode: WheelMode = WheelMode.OUT, center: int = 0) -> _Graph:
    """Type-annotated wrapper for ``igraph_wheel``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_mode = c_int(mode)
    c_center = center

    # Call wrapped function
    igraph_wheel(c_graph, c_n, c_mode, c_center)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_square_lattice: at least one default argument precedes non-default argument periodic


def ring(n: int, directed: bool = False, mutual: bool = False, circular: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_ring``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_mutual = any_to_igraph_bool_t(mutual)
    c_circular = any_to_igraph_bool_t(circular)

    # Call wrapped function
    igraph_ring(c_graph, c_n, c_directed, c_mutual, c_circular)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def kary_tree(n: int, children: int = 2, type: TreeMode = TreeMode.OUT) -> _Graph:
    """Type-annotated wrapper for ``igraph_kary_tree``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_children = children
    c_type = c_int(type)

    # Call wrapped function
    igraph_kary_tree(c_graph, c_n, c_children, c_type)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def symmetric_tree(branches: Iterable[int], type: TreeMode = TreeMode.OUT) -> _Graph:
    """Type-annotated wrapper for ``igraph_symmetric_tree``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_branches = iterable_to_igraph_vector_int_t_view(branches)
    c_type = c_int(type)

    # Call wrapped function
    igraph_symmetric_tree(c_graph, c_branches, c_type)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def regular_tree(h: int, k: int = 3, type: TreeMode = TreeMode.UNDIRECTED) -> _Graph:
    """Type-annotated wrapper for ``igraph_regular_tree``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_h = h
    c_k = k
    c_type = c_int(type)

    # Call wrapped function
    igraph_regular_tree(c_graph, c_h, c_k, c_type)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def full(n: int, directed: bool = False, loops: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_full``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_full(c_graph, c_n, c_directed, c_loops)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def full_citation(n: int, directed: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_full_citation``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_full_citation(c_graph, c_n, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def atlas(number: int = 0) -> _Graph:
    """Type-annotated wrapper for ``igraph_atlas``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_number = number

    # Call wrapped function
    igraph_atlas(c_graph, c_number)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_extended_chordal_ring: no Python type known for type: MATRIX_INT


def connect_neighborhood(graph: _Graph, order: int = 2, mode: NeighborMode = NeighborMode.ALL) -> None:
    """Type-annotated wrapper for ``igraph_connect_neighborhood``."""
    # Prepare input arguments
    c_graph = graph
    c_order = order
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_connect_neighborhood(c_graph, c_order, c_mode)


def linegraph(graph: _Graph) -> _Graph:
    """Type-annotated wrapper for ``igraph_linegraph``."""
    # Prepare input arguments
    c_graph = graph
    c_linegraph = _Graph()

    # Call wrapped function
    igraph_linegraph(c_graph, c_linegraph)

    # Prepare output arguments
    linegraph = c_linegraph.mark_initialized()

    # Construct return value
    return linegraph


def de_bruijn(m: int, n: int) -> _Graph:
    """Type-annotated wrapper for ``igraph_de_bruijn``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_m = m
    c_n = n

    # Call wrapped function
    igraph_de_bruijn(c_graph, c_m, c_n)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def kautz(m: int, n: int) -> _Graph:
    """Type-annotated wrapper for ``igraph_kautz``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_m = m
    c_n = n

    # Call wrapped function
    igraph_kautz(c_graph, c_m, c_n)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def famous(name: str = "") -> _Graph:
    """Type-annotated wrapper for ``igraph_famous``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_name = name

    # Call wrapped function
    igraph_famous(c_graph, c_name)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def lcf_vector(n: int, shifts: Iterable[int], repeats: int = 1) -> _Graph:
    """Type-annotated wrapper for ``igraph_lcf_vector``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_shifts = iterable_to_igraph_vector_int_t_view(shifts)
    c_repeats = repeats

    # Call wrapped function
    igraph_lcf_vector(c_graph, c_n, c_shifts, c_repeats)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_adjlist: no Python type known for type: ADJLIST

# igraph_full_bipartite: no Python type known for type: BIPARTITE_TYPES


def full_multipartite(n: Iterable[int], directed: bool = False, mode: NeighborMode = NeighborMode.ALL) -> Tuple[_Graph, npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_full_multipartite``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorInt.create(0)
    c_n = iterable_to_igraph_vector_int_t_view(n)
    c_directed = any_to_igraph_bool_t(directed)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_full_multipartite(c_graph, c_types, c_n, c_directed, c_mode)

    # Prepare output arguments
    graph = c_graph.mark_initialized()
    types = igraph_vector_int_t_to_numpy_array(c_types)

    # Construct return value
    return graph, types

# igraph_realize_degree_sequence: no Python type known for type: EDGE_TYPE_SW


def circulant(n: int, shifts: Iterable[int], directed: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_circulant``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_shifts = iterable_to_igraph_vector_int_t_view(shifts)
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_circulant(c_graph, c_n, c_shifts, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def generalized_petersen(n: int, k: int) -> _Graph:
    """Type-annotated wrapper for ``igraph_generalized_petersen``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_k = k

    # Call wrapped function
    igraph_generalized_petersen(c_graph, c_n, c_k)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def turan(n: int, r: int) -> Tuple[_Graph, npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_turan``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_types = _VectorInt.create(0)
    c_n = n
    c_r = r

    # Call wrapped function
    igraph_turan(c_graph, c_types, c_n, c_r)

    # Prepare output arguments
    graph = c_graph.mark_initialized()
    types = igraph_vector_int_t_to_numpy_array(c_types)

    # Construct return value
    return graph, types

# igraph_weighted_sparsemat: no Python type known for type: SPARSEMAT

# igraph_barabasi_game: no Python type known for type: BARABASI_ALGORITHM

# igraph_erdos_renyi_game: no Python type known for type: ERDOS_RENYI_TYPE


def erdos_renyi_game_gnp(n: int, p: float, directed: bool = False, loops: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_erdos_renyi_game_gnp``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_p = p
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_erdos_renyi_game_gnp(c_graph, c_n, c_p, c_directed, c_loops)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def erdos_renyi_game_gnm(n: int, m: int, directed: bool = False, loops: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_erdos_renyi_game_gnm``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_m = m
    c_directed = any_to_igraph_bool_t(directed)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_erdos_renyi_game_gnm(c_graph, c_n, c_m, c_directed, c_loops)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_degree_sequence_game: no Python type known for type: DEGSEQ_MODE


def growing_random_game(n: int, m: int = 1, directed: bool = False, citation: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_growing_random_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_n = n
    c_m = m
    c_directed = any_to_igraph_bool_t(directed)
    c_citation = any_to_igraph_bool_t(citation)

    # Call wrapped function
    igraph_growing_random_game(c_graph, c_n, c_m, c_directed, c_citation)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_barabasi_aging_game: at least one default argument precedes non-default argument outseq

# igraph_recent_degree_game: at least one default argument precedes non-default argument outseq

# igraph_recent_degree_aging_game: at least one default argument precedes non-default argument outseq

# igraph_callaway_traits_game: no Python type known for type: MATRIX

# igraph_establishment_game: no Python type known for type: MATRIX


def grg_game(nodes: int, radius: float, torus: bool = False) -> Tuple[_Graph, npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """Type-annotated wrapper for ``igraph_grg_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_radius = radius
    c_torus = any_to_igraph_bool_t(torus)
    c_x = _Vector()
    c_y = _Vector()

    # Call wrapped function
    igraph_grg_game(c_graph, c_nodes, c_radius, c_torus, c_x, c_y)

    # Prepare output arguments
    graph = c_graph.mark_initialized()
    x = igraph_vector_t_to_numpy_array(c_x)
    y = igraph_vector_t_to_numpy_array(c_y)

    # Construct return value
    return graph, x, y

# igraph_preference_game: no Python type known for type: MATRIX

# igraph_asymmetric_preference_game: no Python type known for type: MATRIX


def rewire_edges(graph: _Graph, prob: float, loops: bool = False, multiple: bool = False) -> None:
    """Type-annotated wrapper for ``igraph_rewire_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_prob = prob
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_rewire_edges(c_graph, c_prob, c_loops, c_multiple)


def rewire_directed_edges(graph: _Graph, prob: float, loops: bool = False, mode: NeighborMode = NeighborMode.OUT) -> None:
    """Type-annotated wrapper for ``igraph_rewire_directed_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_prob = prob
    c_loops = any_to_igraph_bool_t(loops)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_rewire_directed_edges(c_graph, c_prob, c_loops, c_mode)


def watts_strogatz_game(dim: int, size: int, nei: int, p: float, loops: bool = False, multiple: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_watts_strogatz_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_dim = dim
    c_size = size
    c_nei = nei
    c_p = p
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_watts_strogatz_game(c_graph, c_dim, c_size, c_nei, c_p, c_loops, c_multiple)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_lastcit_game: at least one default argument precedes non-default argument preference


def cited_type_game(nodes: int, types: Iterable[int], pref: Iterable[float], edges_per_step: int = 1, directed: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_cited_type_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_types = iterable_to_igraph_vector_int_t_view(types)
    c_pref = iterable_to_igraph_vector_t_view(pref)
    c_edges_per_step = edges_per_step
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_cited_type_game(c_graph, c_nodes, c_types, c_pref, c_edges_per_step, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_citing_cited_type_game: no Python type known for type: MATRIX


def forest_fire_game(nodes: int, fw_prob: float, bw_factor: float = 1, ambs: int = 1, directed: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_forest_fire_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_nodes = nodes
    c_fw_prob = fw_prob
    c_bw_factor = bw_factor
    c_ambs = ambs
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_forest_fire_game(c_graph, c_nodes, c_fw_prob, c_bw_factor, c_ambs, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def simple_interconnected_islands_game(islands_n: int, islands_size: int, islands_pin: float, n_inter: int) -> _Graph:
    """Type-annotated wrapper for ``igraph_simple_interconnected_islands_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_islands_n = islands_n
    c_islands_size = islands_size
    c_islands_pin = islands_pin
    c_n_inter = n_inter

    # Call wrapped function
    igraph_simple_interconnected_islands_game(c_graph, c_islands_n, c_islands_size, c_islands_pin, c_n_inter)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def static_fitness_game(no_of_edges: int, fitness_out: Iterable[float], fitness_in: Optional[Iterable[float]], loops: bool = False, multiple: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_static_fitness_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_no_of_edges = no_of_edges
    c_fitness_out = iterable_to_igraph_vector_t_view(fitness_out)
    c_fitness_in = iterable_to_igraph_vector_t_view(fitness_in)
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_static_fitness_game(c_graph, c_no_of_edges, c_fitness_out, c_fitness_in, c_loops, c_multiple)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def static_power_law_game(no_of_nodes: int, no_of_edges: int, exponent_out: float, exponent_in: float = -1, loops: bool = False, multiple: bool = False, finite_size_correction: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_static_power_law_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_no_of_nodes = no_of_nodes
    c_no_of_edges = no_of_edges
    c_exponent_out = exponent_out
    c_exponent_in = exponent_in
    c_loops = any_to_igraph_bool_t(loops)
    c_multiple = any_to_igraph_bool_t(multiple)
    c_finite_size_correction = any_to_igraph_bool_t(finite_size_correction)

    # Call wrapped function
    igraph_static_power_law_game(c_graph, c_no_of_nodes, c_no_of_edges, c_exponent_out, c_exponent_in, c_loops, c_multiple, c_finite_size_correction)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def k_regular_game(no_of_nodes: int, k: int, directed: bool = False, multiple: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_k_regular_game``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_no_of_nodes = no_of_nodes
    c_k = k
    c_directed = any_to_igraph_bool_t(directed)
    c_multiple = any_to_igraph_bool_t(multiple)

    # Call wrapped function
    igraph_k_regular_game(c_graph, c_no_of_nodes, c_k, c_directed, c_multiple)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_sbm_game: no Python type known for type: MATRIX

# igraph_hsbm_game: no Python type known for type: MATRIX

# igraph_hsbm_list_game: no Python type known for type: VECTOR_LIST

# igraph_dot_product_game: no Python type known for type: MATRIX

# igraph_sample_sphere_surface: no Python type known for type: MATRIX

# igraph_sample_sphere_volume: no Python type known for type: MATRIX

# igraph_sample_dirichlet: no Python type known for type: MATRIX


def are_connected(graph: _Graph, v1: VertexLike, v2: VertexLike) -> bool:
    """Type-annotated wrapper for ``igraph_are_connected``."""
    # Prepare input arguments
    c_graph = graph
    c_v1 = vertexlike_to_igraph_integer_t(v1)
    c_v2 = vertexlike_to_igraph_integer_t(v2)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_are_connected(c_graph, c_v1, c_v2, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def diameter(graph: _Graph, directed: bool = True, unconnected: bool = True) -> Tuple[float, int, int, npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_diameter``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()
    c_vertex_path = _VectorInt.create(0)
    c_edge_path = _VectorInt.create(0)
    c_directed = any_to_igraph_bool_t(directed)
    c_unconnected = any_to_igraph_bool_t(unconnected)

    # Call wrapped function
    igraph_diameter(c_graph, c_res, c_from, c_to, c_vertex_path, c_edge_path, c_directed, c_unconnected)

    # Prepare output arguments
    res = c_res.value
    from_ = c_from.value
    to = c_to.value
    vertex_path = igraph_vector_int_t_to_numpy_array(c_vertex_path)
    edge_path = igraph_vector_int_t_to_numpy_array(c_edge_path)

    # Construct return value
    return res, from_, to, vertex_path, edge_path

# igraph_diameter_dijkstra: no Python type known for type: EDGEWEIGHTS

# igraph_closeness: no Python type known for type: VERTEX_QTY

# igraph_closeness_cutoff: no Python type known for type: VERTEX_QTY

# igraph_distances: no Python type known for type: MATRIX


def get_shortest_path(graph: _Graph, from_: VertexLike, to: VertexLike, mode: NeighborMode = NeighborMode.OUT) -> Tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_get_shortest_path``."""
    # Prepare input arguments
    c_graph = graph
    c_vertices = _VectorInt.create(0)
    c_edges = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertexlike_to_igraph_integer_t(to)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_shortest_path(c_graph, c_vertices, c_edges, c_from, c_to, c_mode)

    # Prepare output arguments
    vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
    edges = igraph_vector_int_t_to_numpy_array(c_edges)

    # Construct return value
    return vertices, edges

# igraph_get_shortest_path_bellman_ford: no Python type known for type: EDGEWEIGHTS

# igraph_get_shortest_path_dijkstra: no Python type known for type: EDGEWEIGHTS

# igraph_get_shortest_paths: no Python type known for type: VERTEXSET_LIST

# igraph_get_all_shortest_paths: no Python type known for type: VERTEXSET_LIST

# igraph_distances_dijkstra: no Python type known for type: MATRIX

# igraph_get_shortest_paths_dijkstra: no Python type known for type: VERTEXSET_LIST

# igraph_get_shortest_paths_bellman_ford: no Python type known for type: VERTEXSET_LIST

# igraph_get_all_shortest_paths_dijkstra: no Python type known for type: VERTEXSET_LIST

# igraph_distances_bellman_ford: no Python type known for type: MATRIX

# igraph_distances_johnson: no Python type known for type: MATRIX

# igraph_distances_floyd_warshall: no Python type known for type: MATRIX


def get_all_simple_paths(graph: _Graph, from_: VertexLike, to: VertexSelector = "all", cutoff: int = -1, mode: NeighborMode = NeighborMode.OUT) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_get_all_simple_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_from = vertexlike_to_igraph_integer_t(from_)
    c_to = vertex_selector_to_igraph_vs_t(to, c_graph)
    c_cutoff = cutoff
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_get_all_simple_paths(c_graph, c_res, c_from, c_to, c_cutoff, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_get_k_shortest_paths: no Python type known for type: EDGEWEIGHTS

# igraph_get_widest_path: no Python type known for type: EDGEWEIGHTS

# igraph_get_widest_paths: no Python type known for type: VERTEXSET_LIST

# igraph_widest_path_widths_dijkstra: no Python type known for type: MATRIX

# igraph_widest_path_widths_floyd_warshall: no Python type known for type: MATRIX

# igraph_spanner: no Python type known for type: EDGEWEIGHTS


def subcomponent(graph: _Graph, vid: VertexLike, mode: NeighborMode = NeighborMode.ALL) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_subcomponent``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_subcomponent(c_graph, c_res, c_vid, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_betweenness: no Python type known for type: VERTEX_QTY

# igraph_betweenness_cutoff: no Python type known for type: VERTEX_QTY

# igraph_betweenness_subset: no Python type known for type: VERTEX_QTY

# igraph_edge_betweenness: no Python type known for type: EDGEWEIGHTS

# igraph_edge_betweenness_cutoff: no Python type known for type: EDGEWEIGHTS

# igraph_edge_betweenness_subset: no Python type known for type: VERTEX_QTY

# igraph_harmonic_centrality: no Python type known for type: VERTEX_QTY

# igraph_harmonic_centrality_cutoff: no Python type known for type: VERTEX_QTY

# igraph_pagerank: no Python type known for type: PAGERANKALGO

# igraph_personalized_pagerank: no Python type known for type: PAGERANKALGO

# igraph_personalized_pagerank_vs: no Python type known for type: PAGERANKALGO

# igraph_rewire: no Python type known for type: REWIRING_MODE

# igraph_induced_subgraph: no Python type known for type: SUBGRAPH_IMPL


def subgraph_edges(graph: _Graph, eids: EdgeSelector, delete_vertices: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_subgraph_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_eids = edge_selector_to_igraph_es_t(eids, c_graph)
    c_delete_vertices = any_to_igraph_bool_t(delete_vertices)

    # Call wrapped function
    igraph_subgraph_edges(c_graph, c_res, c_eids, c_delete_vertices)

    # Prepare output arguments
    res = c_res.mark_initialized()

    # Construct return value
    return res


def reverse_edges(graph: _Graph, eids: EdgeSelector = "all") -> None:
    """Type-annotated wrapper for ``igraph_reverse_edges``."""
    # Prepare input arguments
    c_graph = graph
    c_eids = edge_selector_to_igraph_es_t(eids, c_graph)

    # Call wrapped function
    igraph_reverse_edges(c_graph, c_eids)


def average_path_length(graph: _Graph, directed: bool = True, unconn: bool = True) -> Tuple[float, float]:
    """Type-annotated wrapper for ``igraph_average_path_length``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_unconn_pairs = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_unconn = any_to_igraph_bool_t(unconn)

    # Call wrapped function
    igraph_average_path_length(c_graph, c_res, c_unconn_pairs, c_directed, c_unconn)

    # Prepare output arguments
    res = c_res.value
    unconn_pairs = c_unconn_pairs.value

    # Construct return value
    return res, unconn_pairs

# igraph_average_path_length_dijkstra: no Python type known for type: EDGEWEIGHTS


def path_length_hist(graph: _Graph, directed: bool = True) -> Tuple[npt.NDArray[np.float64], float]:
    """Type-annotated wrapper for ``igraph_path_length_hist``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_unconnected = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_path_length_hist(c_graph, c_res, c_unconnected, c_directed)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    unconnected = c_unconnected.value

    # Construct return value
    return res, unconnected

# igraph_simplify: no Python type known for type: EDGE_ATTRIBUTE_COMBINATION

# igraph_transitivity_undirected: no Python type known for type: TRANSITIVITY_MODE

# igraph_transitivity_local_undirected: no Python type known for type: TRANSITIVITY_MODE

# igraph_transitivity_avglocal_undirected: no Python type known for type: TRANSITIVITY_MODE

# igraph_transitivity_barrat: no Python type known for type: EDGEWEIGHTS

# igraph_reciprocity: no Python type known for type: RECIP

# igraph_constraint: no Python type known for type: EDGEWEIGHTS


def maxdegree(graph: _Graph, vids: VertexSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_maxdegree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_vids = vertex_selector_to_igraph_vs_t(vids, c_graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_maxdegree(c_graph, c_res, c_vids, c_mode, c_loops)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def density(graph: _Graph, loops: bool = False) -> float:
    """Type-annotated wrapper for ``igraph_density``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_density(c_graph, c_res, c_loops)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def neighborhood_size(graph: _Graph, vids: VertexSelector, order: int, mode: NeighborMode = NeighborMode.ALL, mindist: int = 0) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_neighborhood_size``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vids = vertex_selector_to_igraph_vs_t(vids, c_graph)
    c_order = order
    c_mode = c_int(mode)
    c_mindist = mindist

    # Call wrapped function
    igraph_neighborhood_size(c_graph, c_res, c_vids, c_order, c_mode, c_mindist)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_neighborhood: no Python type known for type: VERTEXSET_LIST

# igraph_neighborhood_graphs: no Python type known for type: GRAPH_LIST


def topological_sorting(graph: _Graph, mode: NeighborMode = NeighborMode.OUT) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_topological_sorting``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_topological_sorting(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_feedback_arc_set: no Python type known for type: EDGEWEIGHTS


def is_loop(graph: _Graph, es: EdgeSelector = "all") -> npt.NDArray[np.bool_]:
    """Type-annotated wrapper for ``igraph_is_loop``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorBool.create(0)
    c_es = edge_selector_to_igraph_es_t(es, c_graph)

    # Call wrapped function
    igraph_is_loop(c_graph, c_res, c_es)

    # Prepare output arguments
    res = igraph_vector_bool_t_to_numpy_array(c_res)

    # Construct return value
    return res


def is_dag(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_dag``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_dag(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_acyclic(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_acyclic``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_acyclic(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_simple(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_simple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_simple(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_multiple(graph: _Graph, es: EdgeSelector = "all") -> npt.NDArray[np.bool_]:
    """Type-annotated wrapper for ``igraph_is_multiple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorBool.create(0)
    c_es = edge_selector_to_igraph_es_t(es, c_graph)

    # Call wrapped function
    igraph_is_multiple(c_graph, c_res, c_es)

    # Prepare output arguments
    res = igraph_vector_bool_t_to_numpy_array(c_res)

    # Construct return value
    return res


def has_loop(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_has_loop``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_has_loop(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def has_multiple(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_has_multiple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_has_multiple(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def count_multiple(graph: _Graph, es: EdgeSelector = "all") -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_count_multiple``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_es = edge_selector_to_igraph_es_t(es, c_graph)

    # Call wrapped function
    igraph_count_multiple(c_graph, c_res, c_es)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def girth(graph: _Graph) -> Tuple[float, npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_girth``."""
    # Prepare input arguments
    c_graph = graph
    c_girth = igraph_real_t()
    c_circle = _VectorInt.create(0)

    # Call wrapped function
    igraph_girth(c_graph, c_girth, c_circle)

    # Prepare output arguments
    girth = c_girth.value
    circle = igraph_vector_int_t_to_numpy_array(c_circle)

    # Construct return value
    return girth, circle


def is_perfect(graph: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_is_perfect``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_perfect(c_graph, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def add_edge(graph: _Graph, from_: int, to: int) -> None:
    """Type-annotated wrapper for ``igraph_add_edge``."""
    # Prepare input arguments
    c_graph = graph
    c_from = from_
    c_to = to

    # Call wrapped function
    igraph_add_edge(c_graph, c_from, c_to)

# igraph_eigenvector_centrality: no Python type known for type: VERTEX_QTY

# igraph_hub_score: no Python type known for type: VERTEX_QTY

# igraph_authority_score: no Python type known for type: VERTEX_QTY

# igraph_hub_and_authority_scores: no Python type known for type: VERTEX_QTY

# igraph_unfold_tree: at least one default argument precedes non-default argument roots


def is_mutual(graph: _Graph, es: EdgeSelector = "all", loops: bool = True) -> npt.NDArray[np.bool_]:
    """Type-annotated wrapper for ``igraph_is_mutual``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorBool.create(0)
    c_es = edge_selector_to_igraph_es_t(es, c_graph)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_is_mutual(c_graph, c_res, c_es, c_loops)

    # Prepare output arguments
    res = igraph_vector_bool_t_to_numpy_array(c_res)

    # Construct return value
    return res


def has_mutual(graph: _Graph, loops: bool = True) -> bool:
    """Type-annotated wrapper for ``igraph_has_mutual``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_has_mutual(c_graph, c_res, c_loops)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def maximum_cardinality_search(graph: _Graph) -> Tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_maximum_cardinality_search``."""
    # Prepare input arguments
    c_graph = graph
    c_alpha = _VectorInt.create(0)
    c_alpham1 = _VectorInt.create(0)

    # Call wrapped function
    igraph_maximum_cardinality_search(c_graph, c_alpha, c_alpham1)

    # Prepare output arguments
    alpha = igraph_vector_int_t_to_numpy_array(c_alpha)
    alpham1 = igraph_vector_int_t_to_numpy_array(c_alpham1)

    # Construct return value
    return alpha, alpham1


def is_chordal(graph: _Graph, alpha: Optional[Iterable[int]] = None, alpham1: Optional[Iterable[VertexLike]] = None) -> Tuple[bool, npt.NDArray[np.int64], _Graph]:
    """Type-annotated wrapper for ``igraph_is_chordal``."""
    # Prepare input arguments
    c_graph = graph
    c_alpha = iterable_to_igraph_vector_int_t_view(alpha)
    c_alpham1 = vertex_indices_to_igraph_vector_int_t(alpham1)
    c_chordal = igraph_bool_t()
    c_fillin = _VectorInt.create(0)
    c_newgraph = _Graph()

    # Call wrapped function
    igraph_is_chordal(c_graph, c_alpha, c_alpham1, c_chordal, c_fillin, c_newgraph)

    # Prepare output arguments
    chordal = c_chordal.value
    fillin = igraph_vector_int_t_to_numpy_array(c_fillin)
    newgraph = c_newgraph.mark_initialized()

    # Construct return value
    return chordal, fillin, newgraph

# igraph_avg_nearest_neighbor_degree: no Python type known for type: VERTEX_QTY

# igraph_strength: no Python type known for type: VERTEX_QTY


def centralization(scores: Iterable[float], theoretical_max: float = 0, normalized: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_centralization``."""
    # Prepare input arguments
    c_scores = iterable_to_igraph_vector_t_view(scores)
    c_theoretical_max = theoretical_max
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    c__result = igraph_centralization(c_scores, c_theoretical_max, c_normalized)

    # Construct return value
    return c__result


def centralization_degree(graph: _Graph, mode: NeighborMode = NeighborMode.ALL, loops: bool = True, normalized: bool = True) -> Tuple[npt.NDArray[np.float64], float, float]:
    """Type-annotated wrapper for ``igraph_centralization_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)
    c_centralization = igraph_real_t()
    c_theoretical_max = igraph_real_t()
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_centralization_degree(c_graph, c_res, c_mode, c_loops, c_centralization, c_theoretical_max, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    centralization = c_centralization.value
    theoretical_max = c_theoretical_max.value

    # Construct return value
    return res, centralization, theoretical_max

# igraph_centralization_degree_tmax: at least one default argument precedes non-default argument loops


def centralization_betweenness(graph: _Graph, directed: bool = True, normalized: bool = True) -> Tuple[npt.NDArray[np.float64], float, float]:
    """Type-annotated wrapper for ``igraph_centralization_betweenness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_directed = any_to_igraph_bool_t(directed)
    c_centralization = igraph_real_t()
    c_theoretical_max = igraph_real_t()
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_centralization_betweenness(c_graph, c_res, c_directed, c_centralization, c_theoretical_max, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    centralization = c_centralization.value
    theoretical_max = c_theoretical_max.value

    # Construct return value
    return res, centralization, theoretical_max


def centralization_betweenness_tmax(graph: Optional[_Graph], nodes: int = 0, directed: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_centralization_betweenness_tmax``."""
    # Prepare input arguments
    c_graph = graph
    c_nodes = nodes
    c_directed = any_to_igraph_bool_t(directed)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_betweenness_tmax(c_graph, c_nodes, c_directed, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def centralization_closeness(graph: _Graph, mode: NeighborMode = NeighborMode.OUT, normalized: bool = True) -> Tuple[npt.NDArray[np.float64], float, float]:
    """Type-annotated wrapper for ``igraph_centralization_closeness``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_mode = c_int(mode)
    c_centralization = igraph_real_t()
    c_theoretical_max = igraph_real_t()
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_centralization_closeness(c_graph, c_res, c_mode, c_centralization, c_theoretical_max, c_normalized)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)
    centralization = c_centralization.value
    theoretical_max = c_theoretical_max.value

    # Construct return value
    return res, centralization, theoretical_max


def centralization_closeness_tmax(graph: Optional[_Graph], nodes: int = 0, mode: NeighborMode = NeighborMode.OUT) -> float:
    """Type-annotated wrapper for ``igraph_centralization_closeness_tmax``."""
    # Prepare input arguments
    c_graph = graph
    c_nodes = nodes
    c_mode = c_int(mode)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_closeness_tmax(c_graph, c_nodes, c_mode, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_centralization_eigenvector_centrality: no Python type known for type: ARPACKOPT


def centralization_eigenvector_centrality_tmax(graph: Optional[_Graph], nodes: int = 0, directed: bool = False, scale: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_centralization_eigenvector_centrality_tmax``."""
    # Prepare input arguments
    c_graph = graph
    c_nodes = nodes
    c_directed = any_to_igraph_bool_t(directed)
    c_scale = any_to_igraph_bool_t(scale)
    c_res = igraph_real_t()

    # Call wrapped function
    igraph_centralization_eigenvector_centrality_tmax(c_graph, c_nodes, c_directed, c_scale, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def assortativity_nominal(graph: _Graph, types: Iterable[int], directed: bool = True, normalized: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_assortativity_nominal``."""
    # Prepare input arguments
    c_graph = graph
    c_types = iterable_to_igraph_vector_int_t_view(types)
    c_res = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_assortativity_nominal(c_graph, c_types, c_res, c_directed, c_normalized)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def assortativity(graph: _Graph, values: Iterable[float], values_in: Optional[Iterable[float]], directed: bool = True, normalized: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_assortativity``."""
    # Prepare input arguments
    c_graph = graph
    c_values = iterable_to_igraph_vector_t_view(values)
    c_values_in = iterable_to_igraph_vector_t_view(values_in)
    c_res = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_normalized = any_to_igraph_bool_t(normalized)

    # Call wrapped function
    igraph_assortativity(c_graph, c_values, c_values_in, c_res, c_directed, c_normalized)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def assortativity_degree(graph: _Graph, directed: bool = True) -> float:
    """Type-annotated wrapper for ``igraph_assortativity_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_real_t()
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_assortativity_degree(c_graph, c_res, c_directed)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_contract_vertices: no Python type known for type: VERTEX_ATTRIBUTE_COMBINATION

# igraph_eccentricity: no Python type known for type: VERTEX_QTY

# igraph_eccentricity_dijkstra: no Python type known for type: EDGEWEIGHTS


def graph_center(graph: _Graph, mode: NeighborMode = NeighborMode.ALL) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_graph_center``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_graph_center(c_graph, c_res, c_mode)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def radius(graph: _Graph, mode: NeighborMode = NeighborMode.ALL) -> float:
    """Type-annotated wrapper for ``igraph_radius``."""
    # Prepare input arguments
    c_graph = graph
    c_radius = igraph_real_t()
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_radius(c_graph, c_radius, c_mode)

    # Prepare output arguments
    radius = c_radius.value

    # Construct return value
    return radius


def pseudo_diameter(graph: _Graph, start_vid: VertexLike, directed: bool = True, unconnected: bool = True) -> Tuple[float, int, int]:
    """Type-annotated wrapper for ``igraph_pseudo_diameter``."""
    # Prepare input arguments
    c_graph = graph
    c_diameter = igraph_real_t()
    c_start_vid = vertexlike_to_igraph_integer_t(start_vid)
    c_from = igraph_integer_t()
    c_to = igraph_integer_t()
    c_directed = any_to_igraph_bool_t(directed)
    c_unconnected = any_to_igraph_bool_t(unconnected)

    # Call wrapped function
    igraph_pseudo_diameter(c_graph, c_diameter, c_start_vid, c_from, c_to, c_directed, c_unconnected)

    # Prepare output arguments
    diameter = c_diameter.value
    from_ = c_from.value
    to = c_to.value

    # Construct return value
    return diameter, from_, to

# igraph_pseudo_diameter_dijkstra: no Python type known for type: EDGEWEIGHTS

# igraph_diversity: no Python type known for type: EDGEWEIGHTS

# igraph_random_walk: no Python type known for type: EDGEWEIGHTS

# igraph_random_edge_walk: no Python type known for type: EDGEWEIGHTS

# igraph_global_efficiency: no Python type known for type: EDGEWEIGHTS

# igraph_local_efficiency: no Python type known for type: VERTEX_QTY

# igraph_average_local_efficiency: no Python type known for type: EDGEWEIGHTS


def transitive_closure_dag(graph: _Graph) -> _Graph:
    """Type-annotated wrapper for ``igraph_transitive_closure_dag``."""
    # Prepare input arguments
    c_graph = graph
    c_closure = _Graph()

    # Call wrapped function
    igraph_transitive_closure_dag(c_graph, c_closure)

    # Prepare output arguments
    closure = c_closure.mark_initialized()

    # Construct return value
    return closure


def trussness(graph: _Graph) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_trussness``."""
    # Prepare input arguments
    c_graph = graph
    c_trussness = _VectorInt.create(0)

    # Call wrapped function
    igraph_trussness(c_graph, c_trussness)

    # Prepare output arguments
    trussness = igraph_vector_int_t_to_numpy_array(c_trussness)

    # Construct return value
    return trussness

# igraph_is_bigraphical: no Python type known for type: EDGE_TYPE_SW

# igraph_is_graphical: no Python type known for type: EDGE_TYPE_SW

# igraph_bfs: no Python type known for type: BFS_FUNC


def bfs_simple(graph: _Graph, root: VertexLike, mode: NeighborMode = NeighborMode.OUT) -> Tuple[npt.NDArray[np.int64], npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_bfs_simple``."""
    # Prepare input arguments
    c_graph = graph
    c_root = vertexlike_to_igraph_integer_t(root)
    c_mode = c_int(mode)
    c_order = _VectorInt.create(0)
    c_layers = _VectorInt.create(0)
    c_parents = _VectorInt.create(0)

    # Call wrapped function
    igraph_bfs_simple(c_graph, c_root, c_mode, c_order, c_layers, c_parents)

    # Prepare output arguments
    order = igraph_vector_int_t_to_numpy_array(c_order)
    layers = igraph_vector_int_t_to_numpy_array(c_layers)
    parents = igraph_vector_int_t_to_numpy_array(c_parents)

    # Construct return value
    return order, layers, parents

# igraph_dfs: no Python type known for type: DFS_FUNC

# igraph_bipartite_projection_size: no Python type known for type: BIPARTITE_TYPES

# igraph_bipartite_projection: no Python type known for type: BIPARTITE_TYPES

# igraph_create_bipartite: no Python type known for type: BIPARTITE_TYPES

# igraph_incidence: no Python type known for type: BIPARTITE_TYPES

# igraph_get_incidence: no Python type known for type: BIPARTITE_TYPES

# igraph_is_bipartite: no Python type known for type: BIPARTITE_TYPES

# igraph_bipartite_game_gnp: no Python type known for type: BIPARTITE_TYPES

# igraph_bipartite_game_gnm: no Python type known for type: BIPARTITE_TYPES

# igraph_bipartite_game: no Python type known for type: BIPARTITE_TYPES

# igraph_get_laplacian: no Python type known for type: MATRIX

# igraph_get_laplacian_sparse: no Python type known for type: SPARSEMAT

# igraph_connected_components: no Python type known for type: CONNECTEDNESS

# igraph_is_connected: no Python type known for type: CONNECTEDNESS

# igraph_decompose: no Python type known for type: GRAPH_LIST


def articulation_points(graph: _Graph) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_articulation_points``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_articulation_points(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_biconnected_components: no Python type known for type: EDGESET_LIST


def bridges(graph: _Graph) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_bridges``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_bridges(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_cliques: no Python type known for type: VERTEXSET_LIST

# igraph_cliques_callback: no Python type known for type: CLIQUE_FUNC


def clique_size_hist(graph: _Graph, min_size: int = 0, max_size: int = 0) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_clique_size_hist``."""
    # Prepare input arguments
    c_graph = graph
    c_hist = _Vector()
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_clique_size_hist(c_graph, c_hist, c_min_size, c_max_size)

    # Prepare output arguments
    hist = igraph_vector_t_to_numpy_array(c_hist)

    # Construct return value
    return hist

# igraph_largest_cliques: no Python type known for type: VERTEXSET_LIST

# igraph_maximal_cliques: no Python type known for type: VERTEXSET_LIST

# igraph_maximal_cliques_subset: no Python type known for type: VERTEXSET_LIST

# igraph_maximal_cliques_callback: no Python type known for type: CLIQUE_FUNC


def maximal_cliques_count(graph: _Graph, min_size: int = 0, max_size: int = 0) -> int:
    """Type-annotated wrapper for ``igraph_maximal_cliques_count``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_maximal_cliques_count(c_graph, c_no, c_min_size, c_max_size)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no

# igraph_maximal_cliques_file: no Python type known for type: OUTFILE


def maximal_cliques_hist(graph: _Graph, min_size: int = 0, max_size: int = 0) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_maximal_cliques_hist``."""
    # Prepare input arguments
    c_graph = graph
    c_hist = _Vector()
    c_min_size = min_size
    c_max_size = max_size

    # Call wrapped function
    igraph_maximal_cliques_hist(c_graph, c_hist, c_min_size, c_max_size)

    # Prepare output arguments
    hist = igraph_vector_t_to_numpy_array(c_hist)

    # Construct return value
    return hist


def clique_number(graph: _Graph) -> int:
    """Type-annotated wrapper for ``igraph_clique_number``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()

    # Call wrapped function
    igraph_clique_number(c_graph, c_no)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no

# igraph_weighted_cliques: no Python type known for type: VERTEXWEIGHTS

# igraph_largest_weighted_cliques: no Python type known for type: VERTEXWEIGHTS

# igraph_weighted_clique_number: no Python type known for type: VERTEXWEIGHTS

# igraph_independent_vertex_sets: no Python type known for type: VERTEXSET_LIST

# igraph_largest_independent_vertex_sets: no Python type known for type: VERTEXSET_LIST

# igraph_maximal_independent_vertex_sets: no Python type known for type: VERTEXSET_LIST


def independence_number(graph: _Graph) -> int:
    """Type-annotated wrapper for ``igraph_independence_number``."""
    # Prepare input arguments
    c_graph = graph
    c_no = igraph_integer_t()

    # Call wrapped function
    igraph_independence_number(c_graph, c_no)

    # Prepare output arguments
    no = c_no.value

    # Construct return value
    return no

# igraph_layout_random: no Python type known for type: MATRIX

# igraph_layout_circle: no Python type known for type: MATRIX

# igraph_layout_star: no Python type known for type: MATRIX

# igraph_layout_grid: no Python type known for type: MATRIX

# igraph_layout_grid_3d: no Python type known for type: MATRIX

# igraph_layout_fruchterman_reingold: no Python type known for type: MATRIX

# igraph_layout_kamada_kawai: no Python type known for type: MATRIX

# igraph_layout_lgl: no Python type known for type: MATRIX

# igraph_layout_reingold_tilford: no Python type known for type: MATRIX

# igraph_layout_reingold_tilford_circular: no Python type known for type: MATRIX

# igraph_roots_for_tree_layout: no Python type known for type: ROOTCHOICE

# igraph_layout_random_3d: no Python type known for type: MATRIX

# igraph_layout_sphere: no Python type known for type: MATRIX

# igraph_layout_fruchterman_reingold_3d: no Python type known for type: MATRIX

# igraph_layout_kamada_kawai_3d: no Python type known for type: MATRIX

# igraph_layout_graphopt: no Python type known for type: MATRIX

# igraph_layout_drl: no Python type known for type: MATRIX

# igraph_layout_drl_3d: no Python type known for type: MATRIX

# igraph_layout_merge_dla: no Python type known for type: GRAPH_PTR_LIST

# igraph_layout_sugiyama: no Python type known for type: MATRIX

# igraph_layout_mds: no Python type known for type: MATRIX

# igraph_layout_bipartite: no Python type known for type: BIPARTITE_TYPES

# igraph_layout_gem: no Python type known for type: MATRIX

# igraph_layout_davidson_harel: no Python type known for type: MATRIX

# igraph_layout_umap: no Python type known for type: MATRIX

# igraph_layout_umap_3d: no Python type known for type: MATRIX

# igraph_cocitation: no Python type known for type: MATRIX

# igraph_bibcoupling: no Python type known for type: MATRIX

# igraph_similarity_dice: no Python type known for type: MATRIX


def similarity_dice_es(graph: _Graph, es: EdgeSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_similarity_dice_es``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_es = edge_selector_to_igraph_es_t(es, c_graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_dice_es(c_graph, c_res, c_es, c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_dice_pairs(graph: _Graph, pairs: Iterable[VertexPair], mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_similarity_dice_pairs``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_dice_pairs(c_graph, c_res, c_pairs, c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_similarity_inverse_log_weighted: no Python type known for type: MATRIX

# igraph_similarity_jaccard: no Python type known for type: MATRIX


def similarity_jaccard_es(graph: _Graph, es: EdgeSelector = "all", mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_similarity_jaccard_es``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_es = edge_selector_to_igraph_es_t(es, c_graph)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_jaccard_es(c_graph, c_res, c_es, c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def similarity_jaccard_pairs(graph: _Graph, pairs: Iterable[VertexPair], mode: NeighborMode = NeighborMode.ALL, loops: bool = False) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_similarity_jaccard_pairs``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
    c_mode = c_int(mode)
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_similarity_jaccard_pairs(c_graph, c_res, c_pairs, c_mode, c_loops)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_compare_communities: no Python type known for type: COMMCMP

# igraph_community_spinglass: no Python type known for type: EDGEWEIGHTS

# igraph_community_spinglass_single: no Python type known for type: EDGEWEIGHTS

# igraph_community_walktrap: no Python type known for type: EDGEWEIGHTS

# igraph_community_edge_betweenness: no Python type known for type: MATRIX_INT

# igraph_community_eb_get_merges: no Python type known for type: EDGEWEIGHTS

# igraph_community_fastgreedy: no Python type known for type: EDGEWEIGHTS

# igraph_community_to_membership: no Python type known for type: MATRIX_INT

# igraph_le_community_to_membership: no Python type known for type: MATRIX_INT

# igraph_modularity: no Python type known for type: EDGEWEIGHTS

# igraph_modularity_matrix: no Python type known for type: EDGEWEIGHTS


def reindex_membership(membership: Iterable[int]) -> Tuple[npt.NDArray[np.int64], int]:
    """Type-annotated wrapper for ``igraph_reindex_membership``."""
    # Prepare input arguments
    c_membership = iterable_to_igraph_vector_int_t(membership)
    c_new_to_old = _VectorInt.create(0)
    c_nb_clusters = igraph_integer_t()

    # Call wrapped function
    igraph_reindex_membership(c_membership, c_new_to_old, c_nb_clusters)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)
    new_to_old = igraph_vector_int_t_to_numpy_array(c_new_to_old)
    nb_clusters = c_nb_clusters.value

    # Construct return value
    return new_to_old, nb_clusters

# igraph_community_leading_eigenvector: no Python type known for type: EDGEWEIGHTS


def community_fluid_communities(graph: _Graph, no_of_communities: int) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_community_fluid_communities``."""
    # Prepare input arguments
    c_graph = graph
    c_no_of_communities = no_of_communities
    c_membership = _VectorInt.create(0)

    # Call wrapped function
    igraph_community_fluid_communities(c_graph, c_no_of_communities, c_membership)

    # Prepare output arguments
    membership = igraph_vector_int_t_to_numpy_array(c_membership)

    # Construct return value
    return membership

# igraph_community_label_propagation: no Python type known for type: EDGEWEIGHTS

# igraph_community_multilevel: no Python type known for type: EDGEWEIGHTS

# igraph_community_optimal_modularity: no Python type known for type: EDGEWEIGHTS

# igraph_community_leiden: no Python type known for type: EDGEWEIGHTS


def split_join_distance(comm1: Iterable[int], comm2: Iterable[int]) -> Tuple[int, int]:
    """Type-annotated wrapper for ``igraph_split_join_distance``."""
    # Prepare input arguments
    c_comm1 = iterable_to_igraph_vector_int_t_view(comm1)
    c_comm2 = iterable_to_igraph_vector_int_t_view(comm2)
    c_distance12 = igraph_integer_t()
    c_distance21 = igraph_integer_t()

    # Call wrapped function
    igraph_split_join_distance(c_comm1, c_comm2, c_distance12, c_distance21)

    # Prepare output arguments
    distance12 = c_distance12.value
    distance21 = c_distance21.value

    # Construct return value
    return distance12, distance21

# igraph_community_infomap: no Python type known for type: EDGEWEIGHTS

# igraph_graphlets: no Python type known for type: EDGEWEIGHTS

# igraph_graphlets_candidate_basis: no Python type known for type: EDGEWEIGHTS

# igraph_graphlets_project: no Python type known for type: EDGEWEIGHTS

# igraph_hrg_fit: no Python type known for type: HRG

# igraph_hrg_sample: no Python type known for type: HRG

# igraph_hrg_sample_many: no Python type known for type: HRG

# igraph_hrg_game: no Python type known for type: HRG

# igraph_hrg_dendrogram: no Python type known for type: HRG

# igraph_hrg_consensus: no Python type known for type: HRG

# igraph_hrg_predict: no Python type known for type: HRG

# igraph_hrg_create: no Python type known for type: HRG

# igraph_hrg_resize: no Python type known for type: HRG

# igraph_hrg_size: no Python type known for type: HRG

# igraph_get_adjacency: no Python type known for type: MATRIX

# igraph_get_adjacency_sparse: no Python type known for type: SPARSEMAT


def get_edgelist(graph: _Graph, bycol: bool = False) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_get_edgelist``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_bycol = any_to_igraph_bool_t(bycol)

    # Call wrapped function
    igraph_get_edgelist(c_graph, c_res, c_bycol)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_get_stochastic: no Python type known for type: MATRIX

# igraph_get_stochastic_sparse: no Python type known for type: SPARSEMAT

# igraph_to_directed: no Python type known for type: TODIRECTED

# igraph_to_undirected: no Python type known for type: TOUNDIRECTED

# igraph_read_graph_edgelist: no Python type known for type: INFILE

# igraph_read_graph_ncol: no Python type known for type: INFILE

# igraph_read_graph_lgl: no Python type known for type: INFILE

# igraph_read_graph_pajek: no Python type known for type: INFILE

# igraph_read_graph_graphml: no Python type known for type: INFILE

# igraph_read_graph_dimacs_flow: no Python type known for type: INFILE

# igraph_read_graph_graphdb: no Python type known for type: INFILE

# igraph_read_graph_gml: no Python type known for type: INFILE

# igraph_read_graph_dl: no Python type known for type: INFILE

# igraph_write_graph_edgelist: no Python type known for type: OUTFILE

# igraph_write_graph_ncol: no Python type known for type: OUTFILE

# igraph_write_graph_lgl: no Python type known for type: OUTFILE

# igraph_write_graph_leda: no Python type known for type: OUTFILE

# igraph_write_graph_graphml: no Python type known for type: OUTFILE

# igraph_write_graph_pajek: no Python type known for type: OUTFILE

# igraph_write_graph_dimacs_flow: no Python type known for type: OUTFILE

# igraph_write_graph_gml: no Python type known for type: OUTFILE

# igraph_write_graph_dot: no Python type known for type: OUTFILE

# igraph_motifs_randesu: at least one default argument precedes non-default argument cut_prob

# igraph_motifs_randesu_estimate: at least one default argument precedes non-default argument cut_prob

# igraph_motifs_randesu_no: at least one default argument precedes non-default argument cut_prob


def dyad_census(graph: _Graph) -> Tuple[float, float, float]:
    """Type-annotated wrapper for ``igraph_dyad_census``."""
    # Prepare input arguments
    c_graph = graph
    c_mut = igraph_real_t()
    c_asym = igraph_real_t()
    c_null = igraph_real_t()

    # Call wrapped function
    igraph_dyad_census(c_graph, c_mut, c_asym, c_null)

    # Prepare output arguments
    mut = c_mut.value
    asym = c_asym.value
    null = c_null.value

    # Construct return value
    return mut, asym, null


def triad_census(graph: _Graph) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_triad_census``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()

    # Call wrapped function
    igraph_triad_census(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def adjacent_triangles(graph: _Graph, vids: VertexSelector = "all") -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_adjacent_triangles``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Vector()
    c_vids = vertex_selector_to_igraph_vs_t(vids, c_graph)

    # Call wrapped function
    igraph_adjacent_triangles(c_graph, c_res, c_vids)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_local_scan_0: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_0_them: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_1_ecount: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_1_ecount_them: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_k_ecount: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_k_ecount_them: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_neighborhood_ecount: no Python type known for type: EDGEWEIGHTS

# igraph_local_scan_subset_ecount: no Python type known for type: EDGEWEIGHTS


def list_triangles(graph: _Graph) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_list_triangles``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_list_triangles(c_graph, c_res)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res


def disjoint_union(left: _Graph, right: _Graph) -> _Graph:
    """Type-annotated wrapper for ``igraph_disjoint_union``."""
    # Prepare input arguments
    c_res = _Graph()
    c_left = left
    c_right = right

    # Call wrapped function
    igraph_disjoint_union(c_res, c_left, c_right)

    # Prepare output arguments
    res = c_res.mark_initialized()

    # Construct return value
    return res

# igraph_disjoint_union_many: no Python type known for type: GRAPH_PTR_LIST


def union(left: _Graph, right: _Graph) -> Tuple[_Graph, npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_union``."""
    # Prepare input arguments
    c_res = _Graph()
    c_left = left
    c_right = right
    c_edge_map_left = _VectorInt.create(0)
    c_edge_map_right = _VectorInt.create(0)

    # Call wrapped function
    igraph_union(c_res, c_left, c_right, c_edge_map_left, c_edge_map_right)

    # Prepare output arguments
    res = c_res.mark_initialized()
    edge_map_left = igraph_vector_int_t_to_numpy_array(c_edge_map_left)
    edge_map_right = igraph_vector_int_t_to_numpy_array(c_edge_map_right)

    # Construct return value
    return res, edge_map_left, edge_map_right

# igraph_union_many: no Python type known for type: GRAPH_PTR_LIST


def intersection(left: _Graph, right: _Graph) -> Tuple[_Graph, npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_intersection``."""
    # Prepare input arguments
    c_res = _Graph()
    c_left = left
    c_right = right
    c_edge_map_left = _VectorInt.create(0)
    c_edge_map_right = _VectorInt.create(0)

    # Call wrapped function
    igraph_intersection(c_res, c_left, c_right, c_edge_map_left, c_edge_map_right)

    # Prepare output arguments
    res = c_res.mark_initialized()
    edge_map_left = igraph_vector_int_t_to_numpy_array(c_edge_map_left)
    edge_map_right = igraph_vector_int_t_to_numpy_array(c_edge_map_right)

    # Construct return value
    return res, edge_map_left, edge_map_right

# igraph_intersection_many: no Python type known for type: GRAPH_PTR_LIST


def difference(orig: _Graph, sub: _Graph) -> _Graph:
    """Type-annotated wrapper for ``igraph_difference``."""
    # Prepare input arguments
    c_res = _Graph()
    c_orig = orig
    c_sub = sub

    # Call wrapped function
    igraph_difference(c_res, c_orig, c_sub)

    # Prepare output arguments
    res = c_res.mark_initialized()

    # Construct return value
    return res


def complementer(graph: _Graph, loops: bool = False) -> _Graph:
    """Type-annotated wrapper for ``igraph_complementer``."""
    # Prepare input arguments
    c_res = _Graph()
    c_graph = graph
    c_loops = any_to_igraph_bool_t(loops)

    # Call wrapped function
    igraph_complementer(c_res, c_graph, c_loops)

    # Prepare output arguments
    res = c_res.mark_initialized()

    # Construct return value
    return res


def compose(g1: _Graph, g2: _Graph) -> Tuple[_Graph, npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_compose``."""
    # Prepare input arguments
    c_res = _Graph()
    c_g1 = g1
    c_g2 = g2
    c_edge_map1 = _VectorInt.create(0)
    c_edge_map2 = _VectorInt.create(0)

    # Call wrapped function
    igraph_compose(c_res, c_g1, c_g2, c_edge_map1, c_edge_map2)

    # Prepare output arguments
    res = c_res.mark_initialized()
    edge_map1 = igraph_vector_int_t_to_numpy_array(c_edge_map1)
    edge_map2 = igraph_vector_int_t_to_numpy_array(c_edge_map2)

    # Construct return value
    return res, edge_map1, edge_map2

# igraph_induced_subgraph_map: no Python type known for type: SUBGRAPH_IMPL

# igraph_gomory_hu_tree: no Python type known for type: EDGE_CAPACITY

# igraph_maxflow: no Python type known for type: EDGE_CAPACITY

# igraph_maxflow_value: no Python type known for type: EDGE_CAPACITY

# igraph_mincut_value: no Python type known for type: EDGE_CAPACITY

# igraph_st_mincut: no Python type known for type: EDGE_CAPACITY

# igraph_st_mincut_value: no Python type known for type: EDGE_CAPACITY

# igraph_mincut: no Python type known for type: EDGE_CAPACITY

# igraph_residual_graph: no Python type known for type: EDGE_CAPACITY

# igraph_reverse_residual_graph: no Python type known for type: EDGE_CAPACITY

# igraph_st_vertex_connectivity: no Python type known for type: VCONNNEI


def vertex_connectivity(graph: _Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_vertex_connectivity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_vertex_connectivity(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def st_edge_connectivity(graph: _Graph, source: VertexLike, target: VertexLike) -> int:
    """Type-annotated wrapper for ``igraph_st_edge_connectivity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_st_edge_connectivity(c_graph, c_res, c_source, c_target)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def edge_connectivity(graph: _Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_edge_connectivity``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_edge_connectivity(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def edge_disjoint_paths(graph: _Graph, source: VertexLike, target: VertexLike) -> int:
    """Type-annotated wrapper for ``igraph_edge_disjoint_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_edge_disjoint_paths(c_graph, c_res, c_source, c_target)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def vertex_disjoint_paths(graph: _Graph, source: VertexLike, target: VertexLike) -> int:
    """Type-annotated wrapper for ``igraph_vertex_disjoint_paths``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_source = vertexlike_to_igraph_integer_t(source)
    c_target = vertexlike_to_igraph_integer_t(target)

    # Call wrapped function
    igraph_vertex_disjoint_paths(c_graph, c_res, c_source, c_target)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def adhesion(graph: _Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_adhesion``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_adhesion(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def cohesion(graph: _Graph, checks: bool = True) -> int:
    """Type-annotated wrapper for ``igraph_cohesion``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_integer_t()
    c_checks = any_to_igraph_bool_t(checks)

    # Call wrapped function
    igraph_cohesion(c_graph, c_res, c_checks)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def dominator_tree(graph: _Graph, root: VertexLike, mode: NeighborMode = NeighborMode.OUT) -> Tuple[npt.NDArray[np.int64], _Graph, npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_dominator_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_root = vertexlike_to_igraph_integer_t(root)
    c_dom = _VectorInt.create(0)
    c_domtree = _Graph()
    c_leftout = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_dominator_tree(c_graph, c_root, c_dom, c_domtree, c_leftout, c_mode)

    # Prepare output arguments
    dom = igraph_vector_int_t_to_numpy_array(c_dom)
    domtree = c_domtree.mark_initialized()
    leftout = igraph_vector_int_t_to_numpy_array(c_leftout)

    # Construct return value
    return dom, domtree, leftout

# igraph_all_st_cuts: no Python type known for type: EDGESET_LIST

# igraph_all_st_mincuts: no Python type known for type: EDGESET_LIST

# igraph_even_tarjan_reduction: no Python type known for type: EDGE_CAPACITY


def is_separator(graph: _Graph, candidate: VertexSelector) -> bool:
    """Type-annotated wrapper for ``igraph_is_separator``."""
    # Prepare input arguments
    c_graph = graph
    c_candidate = vertex_selector_to_igraph_vs_t(candidate, c_graph)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_separator(c_graph, c_candidate, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res


def is_minimal_separator(graph: _Graph, candidate: VertexSelector) -> bool:
    """Type-annotated wrapper for ``igraph_is_minimal_separator``."""
    # Prepare input arguments
    c_graph = graph
    c_candidate = vertex_selector_to_igraph_vs_t(candidate, c_graph)
    c_res = igraph_bool_t()

    # Call wrapped function
    igraph_is_minimal_separator(c_graph, c_candidate, c_res)

    # Prepare output arguments
    res = c_res.value

    # Construct return value
    return res

# igraph_all_minimal_st_separators: no Python type known for type: VERTEXSET_LIST

# igraph_minimum_size_separators: no Python type known for type: VERTEXSET_LIST

# igraph_cohesive_blocks: no Python type known for type: VERTEXSET_LIST


def coreness(graph: _Graph, mode: NeighborMode = NeighborMode.ALL) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_coreness``."""
    # Prepare input arguments
    c_graph = graph
    c_cores = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_coreness(c_graph, c_cores, c_mode)

    # Prepare output arguments
    cores = igraph_vector_int_t_to_numpy_array(c_cores)

    # Construct return value
    return cores


def isoclass(graph: _Graph) -> int:
    """Type-annotated wrapper for ``igraph_isoclass``."""
    # Prepare input arguments
    c_graph = graph
    c_isoclass = igraph_integer_t()

    # Call wrapped function
    igraph_isoclass(c_graph, c_isoclass)

    # Prepare output arguments
    isoclass = c_isoclass.value

    # Construct return value
    return isoclass


def isomorphic(graph1: _Graph, graph2: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_isomorphic``."""
    # Prepare input arguments
    c_graph1 = graph1
    c_graph2 = graph2
    c_iso = igraph_bool_t()

    # Call wrapped function
    igraph_isomorphic(c_graph1, c_graph2, c_iso)

    # Prepare output arguments
    iso = c_iso.value

    # Construct return value
    return iso


def isoclass_subgraph(graph: _Graph, vids: Iterable[int]) -> int:
    """Type-annotated wrapper for ``igraph_isoclass_subgraph``."""
    # Prepare input arguments
    c_graph = graph
    c_vids = iterable_to_igraph_vector_int_t_view(vids)
    c_isoclass = igraph_integer_t()

    # Call wrapped function
    igraph_isoclass_subgraph(c_graph, c_vids, c_isoclass)

    # Prepare output arguments
    isoclass = c_isoclass.value

    # Construct return value
    return isoclass


def isoclass_create(size: int, number: int, directed: bool = True) -> _Graph:
    """Type-annotated wrapper for ``igraph_isoclass_create``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_size = size
    c_number = number
    c_directed = any_to_igraph_bool_t(directed)

    # Call wrapped function
    igraph_isoclass_create(c_graph, c_size, c_number, c_directed)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph

# igraph_isomorphic_vf2: no Python type known for type: VERTEX_COLOR

# igraph_count_isomorphisms_vf2: no Python type known for type: VERTEX_COLOR

# igraph_get_isomorphisms_vf2: no Python type known for type: VERTEX_COLOR


def subisomorphic(graph1: _Graph, graph2: _Graph) -> bool:
    """Type-annotated wrapper for ``igraph_subisomorphic``."""
    # Prepare input arguments
    c_graph1 = graph1
    c_graph2 = graph2
    c_iso = igraph_bool_t()

    # Call wrapped function
    igraph_subisomorphic(c_graph1, c_graph2, c_iso)

    # Prepare output arguments
    iso = c_iso.value

    # Construct return value
    return iso

# igraph_subisomorphic_vf2: no Python type known for type: VERTEX_COLOR

# igraph_subisomorphic_function_vf2: no Python type known for type: VERTEX_COLOR

# igraph_count_subisomorphisms_vf2: no Python type known for type: VERTEX_COLOR

# igraph_get_subisomorphisms_vf2: no Python type known for type: VERTEX_COLOR

# igraph_canonical_permutation: no Python type known for type: VERTEX_COLOR


def permute_vertices(graph: _Graph, permutation: Iterable[int]) -> _Graph:
    """Type-annotated wrapper for ``igraph_permute_vertices``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_permutation = iterable_to_igraph_vector_int_t_view(permutation)

    # Call wrapped function
    igraph_permute_vertices(c_graph, c_res, c_permutation)

    # Prepare output arguments
    res = c_res.mark_initialized()

    # Construct return value
    return res

# igraph_isomorphic_bliss: no Python type known for type: VERTEX_COLOR

# igraph_automorphisms: no Python type known for type: VERTEX_COLOR

# igraph_automorphism_group: no Python type known for type: VERTEX_COLOR

# igraph_subisomorphic_lad: no Python type known for type: VERTEXSET_LIST


def simplify_and_colorize(graph: _Graph) -> Tuple[_Graph, npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_simplify_and_colorize``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _Graph()
    c_vertex_color = _VectorInt.create(0)
    c_edge_color = _VectorInt.create(0)

    # Call wrapped function
    igraph_simplify_and_colorize(c_graph, c_res, c_vertex_color, c_edge_color)

    # Prepare output arguments
    res = c_res.mark_initialized()
    vertex_color = igraph_vector_int_t_to_numpy_array(c_vertex_color)
    edge_color = igraph_vector_int_t_to_numpy_array(c_edge_color)

    # Construct return value
    return res, vertex_color, edge_color


def graph_count(n: int, directed: bool = False) -> int:
    """Type-annotated wrapper for ``igraph_graph_count``."""
    # Prepare input arguments
    c_n = n
    c_directed = any_to_igraph_bool_t(directed)
    c_count = igraph_integer_t()

    # Call wrapped function
    igraph_graph_count(c_n, c_directed, c_count)

    # Prepare output arguments
    count = c_count.value

    # Construct return value
    return count

# igraph_is_matching: no Python type known for type: BIPARTITE_TYPES

# igraph_is_maximal_matching: no Python type known for type: BIPARTITE_TYPES

# igraph_maximum_bipartite_matching: no Python type known for type: BIPARTITE_TYPES

# igraph_adjacency_spectral_embedding: no Python type known for type: EDGEWEIGHTS

# igraph_laplacian_spectral_embedding: no Python type known for type: EDGEWEIGHTS

# igraph_eigen_adjacency: no Python type known for type: EIGENALGO

# igraph_power_law_fit: no Python type known for type: PLFIT

# igraph_sir: no Python type known for type: SIR_LIST


def running_mean(data: Iterable[float], binwidth: int) -> npt.NDArray[np.float64]:
    """Type-annotated wrapper for ``igraph_running_mean``."""
    # Prepare input arguments
    c_data = iterable_to_igraph_vector_t_view(data)
    c_res = _Vector()
    c_binwidth = binwidth

    # Call wrapped function
    igraph_running_mean(c_data, c_res, c_binwidth)

    # Prepare output arguments
    res = igraph_vector_t_to_numpy_array(c_res)

    # Construct return value
    return res


def random_sample(l: int, h: int, length: int) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_random_sample``."""
    # Prepare input arguments
    c_res = _VectorInt.create(0)
    c_l = l
    c_h = h
    c_length = length

    # Call wrapped function
    igraph_random_sample(c_res, c_l, c_h, c_length)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_convex_hull: no Python type known for type: MATRIX


def dim_select(sv: Iterable[float]) -> int:
    """Type-annotated wrapper for ``igraph_dim_select``."""
    # Prepare input arguments
    c_sv = iterable_to_igraph_vector_t_view(sv)
    c_dim = igraph_integer_t()

    # Call wrapped function
    igraph_dim_select(c_sv, c_dim)

    # Prepare output arguments
    dim = c_dim.value

    # Construct return value
    return dim

# igraph_almost_equals: no Python type known for type: DOUBLE

# igraph_cmp_epsilon: no Python type known for type: DOUBLE

# igraph_eigen_matrix: no Python type known for type: MATRIX

# igraph_eigen_matrix_symmetric: no Python type known for type: MATRIX

# igraph_solve_lsap: no Python type known for type: MATRIX


def is_eulerian(graph: _Graph) -> Tuple[bool, bool]:
    """Type-annotated wrapper for ``igraph_is_eulerian``."""
    # Prepare input arguments
    c_graph = graph
    c_has_path = igraph_bool_t()
    c_has_cycle = igraph_bool_t()

    # Call wrapped function
    igraph_is_eulerian(c_graph, c_has_path, c_has_cycle)

    # Prepare output arguments
    has_path = c_has_path.value
    has_cycle = c_has_cycle.value

    # Construct return value
    return has_path, has_cycle


def eulerian_path(graph: _Graph) -> Tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_eulerian_path``."""
    # Prepare input arguments
    c_graph = graph
    c_edge_res = _VectorInt.create(0)
    c_vertex_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_eulerian_path(c_graph, c_edge_res, c_vertex_res)

    # Prepare output arguments
    edge_res = igraph_vector_int_t_to_numpy_array(c_edge_res)
    vertex_res = igraph_vector_int_t_to_numpy_array(c_vertex_res)

    # Construct return value
    return edge_res, vertex_res


def eulerian_cycle(graph: _Graph) -> Tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_eulerian_cycle``."""
    # Prepare input arguments
    c_graph = graph
    c_edge_res = _VectorInt.create(0)
    c_vertex_res = _VectorInt.create(0)

    # Call wrapped function
    igraph_eulerian_cycle(c_graph, c_edge_res, c_vertex_res)

    # Prepare output arguments
    edge_res = igraph_vector_int_t_to_numpy_array(c_edge_res)
    vertex_res = igraph_vector_int_t_to_numpy_array(c_vertex_res)

    # Construct return value
    return edge_res, vertex_res

# igraph_fundamental_cycles: no Python type known for type: EDGESET_LIST

# igraph_minimum_cycle_basis: no Python type known for type: EDGESET_LIST


def is_tree(graph: _Graph, mode: NeighborMode = NeighborMode.OUT) -> Tuple[bool, int]:
    """Type-annotated wrapper for ``igraph_is_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_root = igraph_integer_t(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_is_tree(c_graph, c_res, c_root, c_mode)

    # Prepare output arguments
    res = c_res.value
    root = c_root.value

    # Construct return value
    return res, root


def is_forest(graph: _Graph, mode: NeighborMode = NeighborMode.OUT) -> Tuple[bool, npt.NDArray[np.int64]]:
    """Type-annotated wrapper for ``igraph_is_forest``."""
    # Prepare input arguments
    c_graph = graph
    c_res = igraph_bool_t()
    c_roots = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_is_forest(c_graph, c_res, c_roots, c_mode)

    # Prepare output arguments
    res = c_res.value
    roots = igraph_vector_int_t_to_numpy_array(c_roots)

    # Construct return value
    return res, roots


def from_prufer(prufer: Iterable[int]) -> _Graph:
    """Type-annotated wrapper for ``igraph_from_prufer``."""
    # Prepare input arguments
    c_graph = _Graph()
    c_prufer = iterable_to_igraph_vector_int_t_view(prufer)

    # Call wrapped function
    igraph_from_prufer(c_graph, c_prufer)

    # Prepare output arguments
    graph = c_graph.mark_initialized()

    # Construct return value
    return graph


def to_prufer(graph: _Graph) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_to_prufer``."""
    # Prepare input arguments
    c_graph = graph
    c_prufer = _VectorInt.create(0)

    # Call wrapped function
    igraph_to_prufer(c_graph, c_prufer)

    # Prepare output arguments
    prufer = igraph_vector_int_t_to_numpy_array(c_prufer)

    # Construct return value
    return prufer

# igraph_minimum_spanning_tree: no Python type known for type: EDGEWEIGHTS


def minimum_spanning_tree_unweighted(graph: _Graph) -> _Graph:
    """Type-annotated wrapper for ``igraph_minimum_spanning_tree_unweighted``."""
    # Prepare input arguments
    c_graph = graph
    c_mst = _Graph()

    # Call wrapped function
    igraph_minimum_spanning_tree_unweighted(c_graph, c_mst)

    # Prepare output arguments
    mst = c_mst.mark_initialized()

    # Construct return value
    return mst

# igraph_minimum_spanning_tree_prim: no Python type known for type: EDGEWEIGHTS


def random_spanning_tree(graph: _Graph, vid: Optional[VertexLike]) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_random_spanning_tree``."""
    # Prepare input arguments
    c_graph = graph
    c_res = _VectorInt.create(0)
    c_vid = vertexlike_to_igraph_integer_t(vid)

    # Call wrapped function
    igraph_random_spanning_tree(c_graph, c_res, c_vid)

    # Prepare output arguments
    res = igraph_vector_int_t_to_numpy_array(c_res)

    # Construct return value
    return res

# igraph_tree_game: no Python type known for type: RANDOM_TREE_METHOD

# igraph_vertex_coloring_greedy: no Python type known for type: VERTEX_COLOR

# igraph_deterministic_optimal_imitation: no Python type known for type: OPTIMALITY

# igraph_stochastic_imitation: no Python type known for type: IMITATE_ALGORITHM

# igraph_moran_process: no Python type known for type: EDGEWEIGHTS

# igraph_roulette_wheel_imitation: no Python type known for type: VERTEX_QTY


def convergence_degree(graph: _Graph) -> Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """Type-annotated wrapper for ``igraph_convergence_degree``."""
    # Prepare input arguments
    c_graph = graph
    c_result = _Vector()
    c_in = _Vector()
    c_out = _Vector()

    # Call wrapped function
    igraph_convergence_degree(c_graph, c_result, c_in, c_out)

    # Prepare output arguments
    result = igraph_vector_t_to_numpy_array(c_result)
    in_ = igraph_vector_t_to_numpy_array(c_in)
    out = igraph_vector_t_to_numpy_array(c_out)

    # Construct return value
    return result, in_, out


def has_attribute_table() -> bool:
    """Type-annotated wrapper for ``igraph_has_attribute_table``."""
    # Call wrapped function
    c__result = igraph_has_attribute_table()

    # Construct return value
    return c__result

# igraph_progress: no Python type known for type: EXTRA

# igraph_status: no Python type known for type: EXTRA

# igraph_strerror: no Python type known for type: ERROR


def expand_path_to_pairs(path: Iterable[VertexLike]) -> None:
    """Type-annotated wrapper for ``igraph_expand_path_to_pairs``."""
    # Prepare input arguments
    c_path = vertex_indices_to_igraph_vector_int_t(path)

    # Call wrapped function
    igraph_expand_path_to_pairs(c_path)

    # Prepare output arguments
    path = igraph_vector_int_t_to_numpy_array(c_path)


def invalidate_cache(graph: _Graph) -> None:
    """Type-annotated wrapper for ``igraph_invalidate_cache``."""
    # Prepare input arguments
    c_graph = graph

    # Call wrapped function
    igraph_invalidate_cache(c_graph)


def vertex_path_from_edge_path(graph: _Graph, start: VertexLike, edge_path: Iterable[EdgeLike], mode: NeighborMode = NeighborMode.OUT) -> npt.NDArray[np.int64]:
    """Type-annotated wrapper for ``igraph_vertex_path_from_edge_path``."""
    # Prepare input arguments
    c_graph = graph
    c_start = vertexlike_to_igraph_integer_t(start)
    c_edge_path = edge_indices_to_igraph_vector_int_t(edge_path)
    c_vertex_path = _VectorInt.create(0)
    c_mode = c_int(mode)

    # Call wrapped function
    igraph_vertex_path_from_edge_path(c_graph, c_start, c_edge_path, c_vertex_path, c_mode)

    # Prepare output arguments
    vertex_path = igraph_vector_int_t_to_numpy_array(c_vertex_path)

    # Construct return value
    return vertex_path

# igraph_version: no Python type known for type: INT
